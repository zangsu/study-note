## 3.5 형식 검사, 형식 추론, 제약

람다 표현식 자체에는해당 표현식이 어떤 함수형 인터페이스를 구현했는지의 정보가 포함되어 있지 않기 때문에 람다의 형식을 검사하여 추론할 필요가 있다.

### 3.5.1 형식 검사

람다가 사용되는 context를 이용해 람다의 형식을 추론할 수 있으며, 이 때 추론하는 람다의 형식을 대상 형식이라 한다.

우리가 사용헀던 람다 표현식을 다시 살펴보자.
```java
List<Apple> filterApple = filter(inventory, 
	 (Apple apple) -> apple.getWeight() > 150
);
```

위 코드에서는 다음의 순서로 형식 확인이 진행된다.
1. `filter()` 메서드의 선언을 확인한다.
2. `filter()` 메서드에서 정의 한 대로 두 번째 파라미터인 람다 표현식을 `Predicate<Apple>` 형식으로 기대한다.
3. 전달 받은 람다 표현식을 `Apple`을 파라미터로 받아 `boolean`을 반환하는 `Predicate<Apple>.test()`의 구현부로 해석한다.

이 때, 람다 표현식이 예외를 던질 수 있다면, 추상 메서드 역시 같은 예외를 던질 수 있도록 `throws`를 선언해 주어야 한다.

### 3.5.2 같은 람다, 다른 함수형 인터페이스

위에서 살펴 본 대상 형식이라는 특징 때문에 같은 람다 표현식이라도, 사용 하는 대상에 따라 다른 함수형 인터페이스로 사용될 수 있다. 

예를 들어, 이전에 살펴본 `Callable`과 `PriviegedAction` 인터페이스는 모두 파라미터를 받지 않으며 제네릭 형식 T를 반환하는 함수를 정의 하기에 다음의 람다 식을 할당할 수 있다.
`() -> 42`

>[!note]
>**void 호환 규칙**
>
>만약 람다의 바디에 일반 표현식이 있다면, `void` 형을 반환하는 함수 디스크립터와 호환 된다.
>즉, `() -> boolean` 형식의 람다 표현식이라도 일반 표현 식을 포함하고 있다면, `() -> void` 형식으로 할당할 수 있다.

```java
//Consumer 은 () -> void 형식의 파라미터를 기대하지만, boolean을 반환하는 list.add()를 할당받을 수 있다.
Consumer<String> c = s-> list.add(s);
```

### 3.5.3 형식 추론

위에서 우리는 컴파일러가 람다 표현식이 구현하는 함수형 인터페이스를 추론한다고 배웠다. 그렇다면, 이 과정에서 함수형 인터페이스에서 정의한 람다 시그니처를 통해 파라미터의 형식에도 접근을 할 수 있다.

즉, 람다 표현식의 파라미터에 형식을 명시해 주지 않더라도, 형식 추론을 통해 해당 파라미터의 형식을 알 수 있다.

```java
List<Apple> greenApple = filter(inventory, 
   apple -> apple.getColor().equals(GREEN));
//파라미터 apple의 형식을 명시하지 않았다.
```

즉, 컴파일러는 람다 표현식에 파라미터의 자료형이 명시되어 있다면, 형식을 추론하지 않으며, 파라미터의 형식이 명시되어 있지 않다면 해당 파라미터의 형식을 추론한다.

### 3.5.4 지역 변수 사용

람다 표현식은 파라미터로 넘겨진 변수 이외에도, 외부에서 정의된 지역 변수를 사용할 수 있으며, 이를 **람다 캡쳐링** _(capturing lambda)_ 라고 부른다. 

하지만, 람다에서 캡쳐할 수 있는 지역 변수는
1. 명시적으로 `final`로 선언이 되어 있거나, 
2. 실질적으로 `final`과 같이 사용되어야 한다.

>참고 : 인스턴스 변수의 캡쳐는 `final` 지역 변수 `this`를 캡쳐하는 것과 마찬가지 이다.

#### 지역 변수의 제약

인스턴스 변수와 달리 지역 변수에 제약이 있는 이유는 JVM의 메모리 구조와 관련이 있다. 

인스턴스 변수의 경우 JVM의 힙 영역에 할당이 되며, 힙 영역은 모든 스레드가 공유하기 때문에 값의 접근에 문제가 없다.

하지만, 지역 변수의 경우 메모리의 스택 영역에 할당이 되며, 이 지역 변수를 캡쳐 할 경우 람다가 동작하는 새로운 스택 영역에 해당 변수를 복사하게 된다. 
때문에 값의 변화에 대한 동기화 문제가 발생할 수 있는 것이다. 

그래서 지역 변수를 람다에서 캡쳐하여 사용할 경우 값이 바뀌지 않아야 한다는 제약 조건이 존재하는 것이다.

