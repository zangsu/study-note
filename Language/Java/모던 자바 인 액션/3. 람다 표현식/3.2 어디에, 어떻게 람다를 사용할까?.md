## 3.2 어디에, 어떻게 람다를 사용할까?

**함수형 인터페이스**라는 문맥에서 람다 표현식을 사용할 수 있음을 알아 두자. 
우선, 함수형 인터페이스가 무엇인지 먼저 살펴 보도록 하자.

### 3.2.1 함수형 인터페이스

우리가 2장에서 만들었던, `Predicate<T>` 인터페이스가 바로 함수형 인터페이스다. `Predicate<T>`는 오직 하나의 추상 메서드만 지정하기 떄문이다.
즉, 함수형 인터페이스는 단 하나만의 추상 메서드를 지정하는 인터페이스이다. 대표적으로는 `Comparator`, `Runnable` 등이 존재한다.

```java
// 함수형 인터페이스 예시
public interface Predicate<T>{
	boolean test(T t);
}

//java.util.Comparator
public interface Comparator<T>{
	int compare(T o1, T o2);
}

//java.lang.Runnable
public interface Runnable{
	void run();
}
```


>나중에 알아보겠지만, 많은 디폴트 메서드를 포함하고 있더라도, 인터페이스 내부의 추상 메서드가 오직 하나라면 해당 인터페이스는 함수형 인터페이스이다.


이제, 우리는 람다 표현식을 사용해 함수형 인터페이스의 추상 메서드 구현을 직접 전달할 수 있다. 즉, 람다 표현식을 함수형 인터페이스의 인스턴스로 취급할 수 있게 되는 것이다.

### 3.2.2 함수 디스크립터

**함수 디스크립터**는 람다 표현식의 시그니처를 서술하는 메서드를 말한다. 파라미터와 반환 값이 모두 존재하지 않는 함수는 `()-> void`, `Apple` 파라미터 두개를 전달 받아 `int`형를 반환하는 함수는 `(Apple a1, Apple a2) -> int` 와 같은 식의 표기법을 사용한다.

람다 표현식의 형식 검사에 대해서는 3.5절에서 설명한다.
일단은 람다 표현식은 변수에 할당하거나, 함수형 인터페이스를 인수로 받는 메서드에 파라미터로 전달할 수 있고, 함수형 인터페이스의 추상 메서드와 같은 시그니처를 갖는다는 사실만 기억하자.

>**`@FunctionalInterface`란?**
>
>해당 어노테이션은 함수형 인터페이스임을 가리키는 어노테이션으로, 해당 인터페이스를 선언헀지만 실제로 함수형 인터페이스가 아니라면 컴파일러가 에러를 발생시켜 준다.

