## 1. 이 책에 관한 대화

해당 책에서는 가상화, 병행성, 영속성의 세가지 주제로 운영체제의 동작에 대해 설명할 예정

> I hear and I forget, I see and I remember, I do and I understand

## 2. 운영체제 개요

운영체제는 프로그램을 쉽게 실행하고, 프로그램 간 메모리 공유를 가능케 하며, 장치와 상호작용을 가능케 하는 등 시스템을 사용하기 편리하도록 서비스를 제공해 주는 서비스라고 요약할 수 있을 듯.

운영체제는 위의 일들을 하기 위해 **가상화**를 이용한다.

### 2.1 CPU 가상화

> **핵심 질문**
>
> 우리의 핵심 문제는 **OS는 어떻게 자원을 가상화 하는가?** <br>
>우리는 그 중에서도 방법에 초점을 맞춘다. 
>-  가상화 효과를 얻기 위해 OS가 구현하는 기법과 정책은 무엇인가?
>- 어떻게 이를 효율적으로 구현하는가?
>- 어떤 하드웨어의 지원이 필요한가?
.notice

단일 프로세서 환경에서 여러개의 프로그램을 동시에 실행시킨다고 가정해 보자. 이 때 역시 프로세서는 마치 여러개의 프로그램이 동시에 실행되는 것 처럼 동작한다. 이는 하드웨어의 도움을 받아 운영체제가 많은 수의 가상 CPU가 존재하는 것 처럼 환상 *(illusion)* 을 제공하는 것이다. 

이 처럼 하나, 또는 소규모의 CPU 집합을 무한개의 CPU가 존재하는 것 처럼 변환해 동시에 많은 수의 프로그램을 실행시키는 것을 **CPU 가상화**_(virtualizing the CPU)_ 라고 한다.

프로그램을 실행하고, 멈추고, 어떤 프로그램을 실행시킬 것인가를 운영체제에 알려주기 위해서는 우리가 원하는 것을 OS에게 전달할 수 있는 **API**가 필요하며, 이 책 전반에서 이런 API들에 대해 논의한다. API는 OS와 사용자가 상호작용할 수 있는 주된 방법이다.
또한, OS가 동작하는 **메커니즘**, 즉 **자원 관리자**로서의 OS의 역할을 다룰 것이다.

### 2.2 메모리 가상화

각 프로세스는 자신만의 **가상 주소 공간**_(virtual address space)_ 를 가지며, OS는 이 가상 주소 공간을 컴퓨터의 물리적인 메모리로 매핑한다. 각각의 프로그램이 수행하는 메모리 연산은 다른 프로그램의 주소 공간에 영향을 주지 않는다.

즉, 실행 중인 프로그램 입장에서는 자신만의 물리 메모리를 가지는 것 처럼 동작한다. 이것이 **메모리 가상화**에 해당한다.

### 2.3 병행성

컴퓨터가 동시에 많은 일을 처리하려 할 때 나타나는 것이 **병행성**_(concurrency)_ 문제이다. 예를 들어, 하나의 프로그램에 존재하는 $N$개의 프로세스가 동시에 전역 변수 `counter`의 값을 $1000$ 증가시킨다면, $N \times 1000$의 값을 가지게 될까? 그렇지 않을 수 있다. 

이는, `counter`의 값을 증가시키는 부분이
1. `counter` 값을 레지스터에 불러 오는 명령어
2. 레지스터의 값을 1 증가 시키는 명령어
3. 레지스터의 값을 다시 메모리의 `counter` 메모리에 저장되는 명령어
의 3가지 명령어로 이루어져 있으며, 각 명령어는 **원자적**_(atomically - 모두 한번에)_ 으로 실행되지 않기 때문이다.

>**핵심 질문**
>
>올바르게 동작하는 병행 프로그램은 어떻게 작성해야 하는가?
>- 같은 메모리 공간에 다수의 쓰레드가 동시 실행 된다고 할 때, 올바르게 동작하는 프로그램은 어떻게 작성할 수 있을까?
>- 운영체제로부터 어떤 메커니즘을 제공 받아야 할까?
>- 하드웨어는 어떤 기능을 제공해야 하는가?

### 2.4 영속성

우리에게는 데이터를 영속적으로 저장하기 위한 시스템이 필요하다. 
디스크를 관리하기 위한 OS 소프트웨어 파일을 **파일 시스템**이라 부른다. 이는 사용자가 생성한 파일을 시스템의 디스크에 안전하고, 효율적으로 저장할 책임을 가진다.

컴퓨터 내의 특정 파일을 사용하기 위해, 프로그램은 필요에 따라 OS를 호출한다. 예를 들어 파일을 생성하고, 파일에 데이터를 쓰거나 읽는 등의 동작을 위해 OS를 호출한다. 이런 **시스템 콜**_(system call)_ 은 파일 시스템에게 전달된다. 그럼 파일 시스템은 요청을 처리하거나, 사용자에게 에러 코드를 반환한다.

이런 내용들을 영속성 부분에서 설명한다.

### 2.5 설계 목표

운영체제는 다양한 물리 자원을 **가상화** 하며, **병행성**과 관련된 문제들을 해결하고, 파일을 **영속적**으로 저장한다. 

이러한 운영체제 소프트웨어를 구현하려면 몇가지 목표가 필요하다. 

가장 기본적인 목표는 시스템을 편리하고, 사용하기 쉽게 만들기 위해 필요한 **개념**_(abstraction)_ 을 정의하는 것이다. 

OS의 설계와 구현에 있어 가장 중요한 목표는 **성능**, 즉 **오버헤드를 최소화** 하는 것이다. 
또한, 각 응용 프로그램 사이, 응용 프로그램과 운영체제 사이에서 의도치 않게 피해를 끼치지 않게 **보호** 해야 한다. 이를 위해 각 프로세스를 다른 프로세스로 부터 **고립** 시키는 것이 필요하다.
운영체제는 높은 **신뢰성**_(reliability)_ 를 제공해야 한다.

이외에도, 에너지 효율성, 보안, 이동성 등의 목표를 가져야 한다.

### 2.6 역사 (약간)

//읽어보고 넘어간다.
