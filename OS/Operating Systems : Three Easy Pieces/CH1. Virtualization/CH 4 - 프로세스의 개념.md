## 4. 프로세스의 개념

일반적으로, **프로세스**는 **실행 중인 프로그램**으로 정의한다.

프로그램은 디스크 상에 존재하며, 실행을 위한 명령어와 정적 데이터의 묶음으로 구성된다. 이 프로그램을 읽고, 실행시키는 것이 OS이다.

사용자는 하나 이상의 프로그램을 동시에 실행시키기를 원한다. 이 때 우리의 도전 과제는 다음과 같다.

>**핵심 질문 : CPU가 여러 개 존재한다는 환상을 어떻게 제공하는가?**
>
>실제로는 컴퓨터에 적은 개수의 CPU만 존재하더라도, 어떻게 OS는 무한개에 가까운 CPU가 있는 듯한 환상을 제공하는가?

OS는 CPU를 가상화 하여 이러한 환상을 만들어낸다. 하나의 프로세스를 실행하고, 시간이 지나면 해당 프로세스를 종료 후 다른 프로세스를 실행하는 작업을 반복해 여러 개의 가상 CPU가 존재하는 듯한 환상을 만들어 낸다. 그리고, 이 기법을 **time sharing** 이라 부른다. time sharing 기법은 CPU를 공유하기에, 프로세스의 성능은 낮아진다.

OS에서 CPU 가상화를 잘 구현하기 위해서는 저수준의 도구와, 고차원의 지능이 필요하다. 이 중 저수준 도구를 **mechanism** 이라 한다. 필요한 기능을 구현하는 방법, 또는 규칙을 의미한다. 예를 들어, 자원 공유를 위해 OS가 사용하는 가장 기본적인 mechanism은 time sharing이다. 

반대로, OS의 지능은 **policy**_(정책)_ 의 형태로 표현된다. 정책은 OS 내에서 어떤 결정을 내리기 위한 알고리즘이다. 예를 들어, 실행 가능한 여러 프로그램이 존재할 때, OS는 어떤 프로그램을 실행시켜야 할 지 결정하기 위해 **scheduling policy**를 사용하여 결정을 내린다.

>**정책의 구현과 분리**
>
>많은 운영체제에서의 공통된 설계 패러다임은 고수준 **정책**_(policy)_ 과 저수준 **기법**_(mechanism)_ 을 분리하는 것이다.<br> 
>기법은 시스템에 관한 **"어떻게"** 라는 질문에 답을 제공하는 것으로, 예를 들어 운영체제는 어떻게 context swithing을 하는가? 등에 해당된다. <br> 
>반대로, 정책은 **"어느 것"** 이라는 질문에 답한다. 예를 들어 운영체제는 지금 당장 어느 프로세스를 실행시켜야 하는가? 등에 해당된다. <br> 
>둘을 분리하면 정책을 변경하더라도 기법의 변경을 고민하지 않아도 된다. 때문에 일반적인 소프트웨어 설계 원칙인 **모듈성**_(modularity)_ 의 한 형태이다.

### 4.1 프로세스의 개념

OS는 실행 중인 프로그램의 개념을 제공하며, 이를 프로세스라 한다.

프로세스의 구성요소를 이해하기 위해서는 하드웨어 상태 _(machine state)_ 를 이해해야 한다. 

프로그램은 실행되는 동안 하드웨어의 상태를 읽거나, 갱신한다. 이 때 가장 중요한 하드웨어 구성요소는 **메모리**이다. 
명령어는 메모리에 저장되며, 실행 프로그램이 읽고 쓰는 데이터 역시 메모리에 저장된다. 이 처럼 프로세스가 접근할 수 있는 메모리 _(주소 공간 : address space)_ 는 프로세스를 구성하는 구성요소이다.

레지스터 역시 하드웨어 상태를 구성하는 요소 중 하나이다. 많은 명령어들이 레지스터를 직접 읽거나 갱신한다. 이 때, 프로세스의 하드웨어 상태를 구성하는 레지스터 중 특별한 레지스터가 존재한다. **PC**_(프로그램 카운터 - Program Counter)_ 는 프로그램의 어느 명령어가 실행중인지를 알려준다. **스택 포인터**_(stack pointer)_ 와 **프레임 포인터**_(frame pointer)_ 는 함수의 변수와 리턴 주소를 저장하는 스택을 관리할 때 사용되는 레지스터이다. 

프로그램은 영구 저장장치 _(persistent storage)_ 에 접근하기도 하는데, 이 입출력 정보는 프로세스가 현재 열어놓은 파일 목록을 가진다.

### 4.2 프로세스 API

운영체제가 반드시 제공해야 하는 몇가지 기본 기능에 대해 간단하게 알아보자. 이 API들은 형태는 다르지만, 모두 현대 운영체제에서 제공하는 API 들이다.

- 생성
	- 운영체제는 새로운 프로세스를 생성할 수 있는 방법을 제공해야 한다. 쉘에 명령어를 입력하거나, 어플리케이션의 아이콘을 더블클릭하여 프로그램을 실행시키면 OS는 새로운 프로세스를 생성한다.
- 제거
	- OS는 프로세스를 강제로 제거할 수 있는 인터페이스도 제공한다. 대부분의 어플리케이션은 할 일이 끝나면 스스로 종료되지만, 때로는 프로세스를 중단시키는 API가 필요해 진다.
- 대기
	- 어떤 프로세스를 잠시 멈춰두기 위해 여러 종류의 대기 인터페이스가 제공된다.
- 각종 제어
	- 프로세스의 제거, 대기 이외에도 여러가지 기능들이 제공된다. 예를 들어, 대부분의 OS는 프로세스를 일시정지 하거나 다시 시작하는 기능을 제공한다.
- 상태
	- 프로세스의 상태 정보를 얻기 위한 인터페이스 또한 제공된다. 상태 정보에는 프로세스가 어떤 상태에 있고, 얼마 동안 실행되었는지 등의 정보가 포함된다.

### 4.3 프로세스 생성 : 더 자세하게

그렇다면 OS는 어떻게 프로그램을 프로세스로 생성할까?

프로그램의 실행을 위해 OS가 하는 가장 첫번째 작업은 프로그램 코드와 static data를 메모리, 프로세스의 주소 공간에 불러오는 _(load)_ 것 입니다. 프로그램은 디스크나 SSD에 특정 실행 파일 형식으로 존재하며, 이를 메모리에 불러 오기 위해 OS는 디스크의 해당 바이트를 읽어 메모리의 어딘가에 저장해야 한다.

과거에는 프로그램 실행 전에 모든 코드와 데이터를 메모리에 불러 왔으나, 현대의 OS는 이 작업을 늦추어 프로그램 실행 중 코드나 데이터가 필요한 시점에 필요한 부분만 메모리에 불러온다. 이는 추후 메모리 가상화에서 다룰 **페이징**_(paging)_ 과 **스와핑**_(swapping)_ 에 해당된다. 지금 은 어떤 프로그램이던 실행되기 전에는 OS가 프로그램의 중요 부분은 메모리에 로드한다는 것만 기억하자.

이후, 일정 크기의 메모리가 프로그램의 **run-time stack** 으로 할당되어야 한다. OS는 스택을 주어진 인자, 즉 `main()` 함수의 인자인 `argc`와 `argv`를 사용하여 초기화한다.
또, 프로그램의 **heap** 영역을 위한 메모리 영역을 할당한다. 이 공간은 동적으로 할당된 데이터들을 저장하기 위해 사용된다.

또, OS는 입출력과 관계된 초기화 작업을 수행한다. `UNIX` 시스템의 경우 표준 입출력에 해당하는 세개의 파일 디스크립터를 사용해 프로그램에서의 입출력을 쉽게 할 수 있도록 하는데, 이 부분은 3장인 영속성에서 다루게 된다.

이 과정이 모두 진행되고 나면 OS는 프로그램 실행을 위한 준비가 끝나게 된다. 이제 프로그램의 **entry point**, 즉 `main()` 에서 프로그램 실행을 위해 `main()` 루틴으로 분기하여 CPU를 새로 생성된 프로세스에게 넘기고, 프로그램이 실행된다.

### 4.4 프로세스 상태

이번엔 프로세스 상태에 대해 알아보자.

프로세스 상태를 단순화 하면 다음의 세가지 상태 중 하나의 상태를 가지게 된다.

- 실행 _(Running)_
	- 이 상태는 말 그대로 프로세서에서 실행 중인 상태를 말한다.
- 준비 _(Ready)_
	- 이 상태에서 프로세스는 실행 될 준비가 끝났으며, 운영체제가 다른 프로세스를 실행하는 등의 이유로 대기중이다.
- 대기 _(Blocked)_
	- 프로세스가 입출력의 완료를 기다리는 등 다른 사건을 기다리는 동안 프로세스의 수행이 중단되어 있는 상태이다.

![Pasted image 20230626220850](https://github.com/zangsu/study-note/assets/76612738/3cad8de7-4077-49c9-9414-9f59ee3719a1)

위 그림은 세가지 상태의 변화를 나타낸 것이다.
Running _(실행)_ 중이던 프로세스가 입출력을 시작한다면 Blocked _(대기)_ 상태가 되고, 입출력이 끝나면 다시 Ready _(준비)_ 상태가 된다. 운영체제는 스케쥴러를 통해 프로세스들의 실행을 다룬다.

### 4.5 자료구조

운영체제도 일종의 프로그램이며, 다른 프로그램과 마찬가지로 다양한 정보를 저장하기 위한 자료구조를 가지고 있다. 예를 들어, 프로세스 상태를 파악하기 위해 준비 상태의 프로세스들을 위한 **Process list**와 같은 자료구조를 가진다. 

또, **register context** 자료구조는 프로세스가 중단되었을 때 해당 프로세스의 레지스터 값들을 저장하기도 한다. 

### 4.6 요약

프로세스는 실행 중인 프로그램을 말한다. 이를 염두에 두고, 더 구체적인 핵심 사항을 살펴보자. 프로세스 구현에 필요한 기법, 구현한 프로세스를 스케쥴링 하는 정책 등을 살펴보며 OS가 CPU를 가상화 하는 방식을 알아볼 것이다.
