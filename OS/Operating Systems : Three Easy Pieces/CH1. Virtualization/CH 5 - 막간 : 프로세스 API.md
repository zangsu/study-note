## 5. 막간 : 프로세스 API

>**여담 : 막간**
>
>이번 절에서는 운영체제 API와 그 사용법을 포함한 시스템의 실제적인 측면을 다룬다.

이번 절에서는 `UNIX` 시스템의 프로세스 생성에 관해 논의한다. `UNIX` 시스템은 프로세스를 생성하기 위해 `fork()` 와 `exec()` 시스템 콜을 사용한다. 또, 자신이 생성한 프로세스가 종료될 때 까지 기다리기 위해 `wait()` 시스템 콜을 사용한다.

>**핵심 질문 : 프로세스를 생성하고 제어하는 방법**
>
>프로세스를 생성, 제어하기 위해선 OS가 어떤 인터페이스를 제공해야 하나? 사용하기에 유용하고, 편리하려면 이 인터페이스는 어떻게 설계되어야 하나?

### 5.1 fork() 시스템 콜

프로세스 생성에는 `fork()` 시스템 콜이 사용된다.

`fork()` 함수는 호출되는 순간, 실행중인 프로세스와 똑같은 프로세스 복사본을 생성한다. 새로 생성된 프로세스는 방금 호출된 `fork()` 함수의 리턴값이 반환되는 순간부터 동작한다. 새로 생성된 프로세스 역시 별개의 프로세스로, 자신의 주소 공간과 자신의 레지스터, 자신만의 PC 값을 받는다. 
가장 중요한 점은, 기존에 실행되고 있던 부모 프로세스는 `fork()` 메서드의 반환값으로 새로 생성된 자식 프로세스의 PID를 반환받는 반면, 자식 프로세스는 0을 반환받는다. 이 덕분에 부모 프로세스와 자식 프로세스는 서로 다른 코드를 실행하는 프로그램으로 동작할 수 있다.

이 때, 자식 프로세스가 생성된 이후 부모 프로세스와 자식 프로세스 중 어떤 프로세스가 먼저 실행될 지는 단정할 수 없다. 이 **비결정성**_(nondeterminism)_ 으로 인해 멀티 스레드 프로그램에서는 다양한 문제가 발생하며, 이는 2장 병행성 부분에서 다룬다.

### 5.2 wait() 시스템 콜

`fork()` 메서드를 실행시킨 부모 프로세스는 자식 프로세스의 종료를 대기해야 하는 경우가 생긴다. 이를 위해 `wait()` 시스템 콜이 사용될 수 있다.

부모 프로세스는 `wait()` 함수가 호출된 시점부터 자식 프로세스가 종료될 때 까지 자신의 실행을 중지시킨다. 이후 자식 프로세스가 종료되면 `wait()` 가 반환한다.

### 5.3 exec() 시스템 콜

`exec()` 시스템 콜은 자신이 아닌, 다른 프로그램을 실행해야 할 때 사용한다. `exec()` 시스템 콜 _(사실 이 시스템콜에는 6가지의 변형 `execl()`, `execvp()`, ...가 존재한다.)_ 이 호출되면 파라미터로 전달된 실행파일의 코드와 static data를 읽어 현재 실행중인 프로세스의 코드 영역과 데이터 영역에 덮어 쓴다. 힙과 스택 영역 역시 새로운 프로그램의 실행을 위해 초기화 된다. 즉, 새로 생성된 자식 프로세스에서 `exec()` 시스템 콜을 호출하면 자식 프로세스를 새로운 프로세스로 대체하는 것이다.
`exec()` 함수의 호출이 성공하면 새로운 프로세스는 리턴하는 대신, 종료된다.

### 5.4 왜, 이런 API를?

그저, 새로운 프로세스를 생성하는 간단한 작업에 왜 이런 인터페이스를 사용해야 할까?

`UNIX` 쉘을 구현하기 위해서는 `fork()`와 `exec()`를 구분해야 한다. 쉘이 `fork()`와 `exec()` 사이에서 코드를 실행할 수 있게 하기 위해서이다. 이 때 코드에서는 프로그램의 환경을 설정하고, 다양한 기능을 준비한다. 

쉘은 단순한 사용자 프로그램이다. 쉘은 사용자의 입력을 기다리고, 프로그램 실행을 위한 명령어를 실행한다. 
대부분의 쉘은 프로그램 실행을 위해 `fork()`를 실행하여 새로운 자식 프로세스를 만든다. 이후 `exec()`의 변형 중 하나를 호출해 프로그램을 실행시키고, `wait()`을 호출해 명령어가 끝나기를 기다린다. 자식 프로세스가 종료되면 쉘은 `wait()`로부터 리턴하고, 다음 명령을 기다린다. 

이 과정 속에서 `fork()`와 `exec()`의 분리는 다양한 일을 쉽게 할 수 있다. 
다음 예를 보자.
`prompt> wc p3.c > newfile.txt`
위 명령어는 `wc`의 실행 결과를 화면에 출력하는 대신 `newfile.txt`에 저장한다.
이러한 작업이 수행되는 방법은 간단하다. `fork()`로 자식 프로세스가 실행된 이후, `exec()` 명령어가 실행되기 전에 표준 출력 파일을 닫고, `newfile.txt` 파일을 연다. 이 과정 이후 `wc`의 출력은 화면이 아닌 파일로 보내진다.

더 자세한 예를 보자. 다음은 입출력을 재지정 하는 프로그램의 동작이다.
```c
// p4.c
#include ...

int main(int argc, char* argv[]){
	int rc = fork();
	if(rc < 0){
		fprintf(stderr, "fork failed\n");
		exit(1);
	}else if(rc == 0){
		close(STDOUT_FILENO);
		open("./p4.output", O_CREATE|O_WRONLY|O_TRUNC, S_IRWXU);

		char *myars[3];
		myargs[0] = strdup("wc");
		myargs[1] = strdup("p4.c");
		myargs[2] = NULL;
		execvp(myargs[0], myargs); //"wc"를 실행한다.
	}else{
		int wc = wait(NULL);
	}

	return 0;
}
```

위 코드는 가장 먼저 표준 출력 파일을 닫는다. 그 다음 `open()`이 호출되는데, 이 때 `STDOUT_FILENO`가 탐색되며 해당 파일 디스크립터로 `p4.output`이 열린다. 
이후엔 표준 파일 디스크립터를 대상으로 하는 모든 출력은 화면이 아닌, 새로 열린 파일에 전달된다.

`UNIX`의 파이프는 이와 유사하게 구현되지만, `pipe()` 시스템콜을 통해 생성된다. 이 경우, 하나의 프로세스의 출력과 다른 프로세스의 입력이 동일한 파이프에 연결된다. 하나의 프로세스의 출력은 자연스럽게 다음 프로세스의 입력으로 사용된다.

### 5.5 여타 API들

`UNIX` 시스템에는 이외에도 다양한 프로세스 관련 인터페이스가 존재한다. 예를 들면, `kill()` 시스템콜은 `signal`을 보내는 데 사용된다. `signal`은 프로세스를 중단시키거나, 삭제하는 등의 작업에 사용된다. 

### 5.6 요약

이번 장에서는 프로세스를 다루는 몇가지 API에 대해 알아보았다.
