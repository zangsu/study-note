## 4.1 사라진 SQLException

우리의 코드를 `JdbcContext`에서 `JdbcTemplate`로 리팩토링을 하면서, 코드에는 또 다른 변화가 생겼다.
```java
//리팩토링 전
public void deleteAll() throws SQLException{
	this.jdbcContext.executeSql("delete from users");
}

//리팩토링 후
public void deleteAll(){
	this.jdbcTemplate.update("delete from users");
}
```

어떻게, `SQLException`을 없앨 수 있었을까?

### 4.1.1 초난감 예외처리

우선, 그 전에 개발자의 코드에서 종종 발견되는 초난감 예외처리의 예시들을 알아보자.

#### 예외 블랙홀

아래의 코드들은 모두 일부 자바 개발자들의 코드에서 쉽게 찾아볼 수 있는 예외처리들이다.
```java
//1. 
try{ //...
}catch(Exception e){
}

//2.
}catch(Exception e){
	System.out.println(e);
}

//3. 
}catch(Exception e){
	e.printStackTrace();
}
```

1번 코드의 경우, 당연히 예외를 잡은 채 아무 것도 하지 않기 때문에 예외 발생을 무시해 버린다. 때문에 예외를 알아차리기 더욱 힘들어지며, 이는 곧 다른 문제를 야기한다.

2, 3번의 경우도 마찬가지이다. 개발 환경에서라면 콘솔에서 예외 메시지를 어렵지 않게 확인할 수 있겠지만, 운영 서버에서는 다른 로그들과 메시지에 묻혀 처리하기 힘든 예외를 만들어 버릴 수 있다.

예외를 처리할 때 반드시 지켜야 하는 핵심 원칙은 한가지, 
>모든 예외는 적절하게 복구되든지 아니면 작업을 중단시키고 운영자 또는 개발자에게 분명하게 통보되어야 한다.

메서드 내부에서 예외를 잡아서 처리할 수 있는 방법이 없다면, 잡지 않은 채 메서드 밖으로 던져 자신을 호출한 코드에 예외 처리 책임을 전가해야 한다.

#### 무의미하고 무책임한 throws

마찬가지로, 예외를 제대로 처리하지 않은 채 무작정 메서드 선언에 `throws Exception`을 붙이는 개발자 역시 존재한다.
```java
public voic method1() thorws Exceptoin{...}
```

물론, 이는 모든 예외를 먹어 치우는 예외 블랙홀보다는 조금 낫지만, 이 역시 심각한 문제가 있다.
우리가 `throws Exception`을 붙인 메서드를 사용한다고 생각해 보자. 우리는 해당 메서드가 동작하는 동안, 정말 어떤 예외가 발생할 것인지, 그렇다면 어떤 종류의 예외가 발생할 것인지 등의 의미있는 정보를 얻을 수 없다.

때문에, 해당 메서드 사용에 있어서 적절한 예외 처리는 불가능해 진다.

위의 두 나쁜 습관은 어떤 경우에도 용납하지 않아야 한다.

### 4.1.2 예외의 종류와 특징

자바에서 `throw`를 통해 발생시킬 수 있는 예외는 크게 3가지가 있다.

#### Error

가장 먼저, `java.lang.Error` 클래스의 서브클래스들이다. 이는 시스템의 비정상적인 상황에서 자바 VM이 발생시키는 것인데, `OutOfMemoryError`나 `ThreadDeath`같은 예외가 있다. 이는 `catch`블럭으로 잡으려 해 봤자 대응 방법이 없기에 어플리케이션 코드에서 잡으려고 하면 안된다.

#### Exception과 체크 예외

`java.lang.Exception` 클래스와 그 서브 클래스의 예외들은 어플리케이션 코드의 작업 중에 발생하는 예외의 상황에 사용된다.

`Exception` 클래스는 다시 `RunTimeException`을 상속하는 언체크 예외와 `RunTimeException`을 상속하지 않고, `Exception`만 상속하는 체크 예외로 구분한다.
체크 예외가 발생할 경우, 반드시 예외를 처리하는 코드를 함께 작성해야 한다. 즉, `try-catch`로 예외 처리를 해 주던지, 메서드 선언시 `throws`를 사용해서 메서드 밖으로 예외를 던져야 한다. 

반대로, `java.lang.RuntimeException`을 상속한 언체크 예외들은 코드를 작성할 때 미리 조건을 체크하여 주의를 기울인다면 피할 수 있는 예외들이며, 이들의 경우 굳이 예외 처리 코드를 작성해 주지 않아도 잘 동작한다. 

### 4.1.3 예외처리 방법

#### 예외 복구

먼저, 예외 상황을 파악하고 문제를 해결하여 정상 상태로 돌려 놓는 방법이 있다. 
만약, 원격 DB 서버에 접속하다가 네트워크가 불안정하여 `SQLException`이 발생한다면, 일정 시간 이후 다시 접속을 시도해 보면서 예외 상황으로부터 복구를 시도할 수 있다. _(물론, 일정 횟수 이상 실패한다면 예외 복구는 포기하는 것이 올바르다.)_ 

예외 처리 코드를 강제하는 체크 예외들은 이렇게 예외를 어떤식으로든 복구할 수 있는 경우에 사용한다. 

```java
int maxRetry = MAX_RETRY;
while(maxRetry-- > 0){
	try{
		//예외 발생 가능성이 있는 코드
		return;
	}catch(SomeException e){
		//로그 출력 및 대기
	}finally{
		//리소스 반납 및 정리
	}
}
throw new RetryFailedException();
```

#### 예외 처리 회피

두번째는, 자신이 예외 처리를 직접 하지 않은 채 자신을 호출한 쪽으로 던져버리는 것이다. 
```java
//1. 
public void add()throws SQLException{...}

//2.
public void add() throws SQLException{
	try{}catch(SQLException e){ throw e; }
}
```

우리가 작성했던, `JdbcContext`를 사용하는 콜백 오브젝트는 콜백과 템플릿이 긴밀하게 역할을 분담하고 있기 때문에 예외를 던져 주는 것이 자연스럽다. 
하지만, 무작정 모든 곳에서 예외 처리를 회피하는 것은 좋지 않다.

예외를 회피할 때는, 콜백/템플릿 처럼 긴밀한 관계에 있는 다른 오브젝트들에게 예외 처리 책임을 분명히 지게 하거나, 자신을 사용하는 쪽에서 예외를 다루는 게 최선의 방법이라는 분명한 확신이 있어야 한다.

#### 예외 전환

예외 회피와 마찬가지로, 예외를 메서드 밖으로 던지지만 이번에는 발생한 예외를 적절한 예외로 전환해서 던지게 된다.

이는 
1. 내부에서 발생한 예외를 그대로 던지는 것이 예외 상황에 대한 적절한 의미를 부여해 주지 못하거나,
2. 예외를 처리하기 쉽고 단순하게 만들기 위해 포장하는 목적으로 
사용된다.

만약, 새로운 사용자를 등록하려고 하는 경우, 아이디가 같은 사용자가 존재해 `SQLException`이 발생했다고 가정하자. 이 경우, `SQLException`을 그대로 밖으로 던져 버리면 메서드 외부에서는 예외 발생 이유를 확인할 수 없어진다. 
이럴 땐, 의미가 분명한 적절한 예외로 전환하여 예외를 던져줄 수 있다. 

보통 예외를 전환하는 경우, 원래 발생한 예외를 담아서 중첩 예외로 만드는 것이 좋다. 중첩 예외는 `getCause()` 메서드를 이용해 처음 발생한 예외를 확인할 수 있게 된다. 
```java
//1.
catch(SQLException e){
	//...
	throw DuplicateUserIdException(e);
}

//2.
catch(SQLException e){
	//...
	throw DuplicateUserIdException().initCause(e);
}
```

두번째 목적에 관련된 대표적인 예시로는 `EJBException`이 존재한다. 특정 코드에서 발생하는 체크 예외들이 비즈니스 로직으로 볼 때, 의미 있는 예외이거나 복구 가능한 예외가 아닌 경우 언체크 예외 _(\==런타임 예외)_ 로 포장해서 외부로 던지는 것이다. 

이렇게 런타임 예외로 만들어서 외부로 던지면 해당 메서드를 이용하는 다른 클라이언트에서 일일이 예외를 처리해 주어야 하는 수고를 겪을 필요가 없어진다. 
이는 예외를 잡아도 처리할 수 있는 방법이 없기 때문에 사용하는 것이다. 

즉, 특정 예외에 대해 적절한 대응이나 복구 작업이 가능하며, 필요한 경우에는 예외 처리를 강제하는 체크 예외를, 그렇지 않고 예외를 잡아도 처리해 주기 어려운 경우에는 예외 처리를 강제하지 않는 언체크 예외를 사용하는 것이 적절하다. 
어짜피 복구하지 못할 예외라면 어플리케이션 코드에서는 런타입 예외로 포장해서 던지고, 로그를 남기며 관리자와 사용자에게 적절히 알려주는 것이 바람직하다.

### 4.1.4 예외 처리 전략

#### 런타임 예외의 보편화

일반적으로 체크 예외는 복구할 가능성이 조금이라도 있는 상황에서 예외 처리를 강제하기 위해 사용한다. 하지만, 일반적으로는 모든 예외의 경우에서 예외 처리가 가능한 것은 아니다. 

특히, 자바로 구현된 웹 서버 환경에서는 예외의 상황에서 프로그램을 중지시키고, 사용자와 커뮤니케이션을 하며 예외 상황을 복구할 수 있는 방법이 없다.
이런 경우에는 애플리케이션 상황에서 예외 상황을 미리 파악하고, 예외가 발생하지 않도록 차단하는 것이 좋다.

자바의 환경이 서버로 이동하면서 체크 예외의 활용도와 가치가 점점 낮아지고 있다. 그래서 대응이 불가능한 체크 예외는 빨리 런타임 예외로 전환해서 던지는 것이 차라리 낫다. 

최근 등장하는 오픈소스 프레임워크에서는 API가 발생시키는 예외를 언체크 예외로 정의하는 것이 일반화 되고 있다. 

#### add() 메서드의 예외처리

우리가 작성한 `add()`예외는 `DuplicatedUserIdException`, `SQLException` 두가지 체크 예외를 던지고 있다. 그런데, 이 중 `SQLException`은 복구가 불가능하기에 잡아도 별로 처리해 줄 방법이 없다. 이런 경우에는 런타임 예외로 포장해 던져 `add()`를 호출하는 메서드들이 신경쓰지 않도록 해 주는 것이 낫다. 

`DuplicateUserIdException` 역시 체크 예외로 둘 필요는 없다. 이 예외의 처리는 `add()` 메서드를 호출한 오브젝트가 처리해 줄 수도 있지만, 더 높은 계층에서 처리를 하는 것이 더 나을 떄도 있다. 어디서든 예외를 처리해 줄 수 있다면, 런타임 에외로 만드는 것이 좋다. 
대신, `add()` 메서드를 호출하는 사용자가 예외처리를 하거나, 참고할 수 있도록 `DuplicateUserIdException`을 던진다고 선언을 해 주어야 한다. 

먼저, `DuplicateUserIdException` 예외를 런타임 예외로 만들어 주자.
```java
public class DuplicateUserIdException extends RuntimeException{
	public DuplicateUserIdException(Throwable cause){
		super(cause);
	}
}
```

다음으로, `add()` 메서드는 `SQLException`은 완전한 언체크 예외로, `DuplicateUserIdException`은 명시된 언체크 예외로 만들어 준다.
```java
public void add() throws DuplicateUserIdException{
	try{
		//예외 발생 가능 코드
	}catch(SQLException e){
		if(e.getErrorCode() == MysqlErrorNumbers.ER_DUP_ENTRY)
			throw new DuplicateUserIdException(e);
		else
			throw new RuntimeException(e);
	}
}
```

이제 `add()` 메서드를 사용하는 오브젝트는 `SQLException`을 처리하기 위해 불필요한 코드를 작성할 필요가 없었으며, 필요한 경우에는 `DuplicateUserIdException`을 처리할 수 있게 되었다. 

하지만, 이제 런타임 예외를 만들었기 때문에 예외 상황을 충분히 고려하지 않을 수도 있다. 때문에 이를 오픈소스 등으로 만든다면 예외의 종류와 원인, 활용 방법을 자세히 설명해 두자.

#### 애플리케이션 예외

런타임 예외 중심 전략은 낙관적인 예외 처리 기법이라고 할 수 있다. 이는, 혹시 놓칠 수 있으니 일단 예외를 잡고 보도록 강제하는 체크 예외의 비관적인 접근 방법과 대비된다.

반면, 어플리케이션 자체 로직에 의해 의도적으로 발생시키고, 반드시 `catch` 해서 조치를 취하도록 요구하는 예외도 있는데, 이를 **어플리케이션 예외**라고 한다. 

은행 계좌에서 사용자가 요청한 금액을 출금하는 메서드를 구현한다고 가정하자. 물론, 이 때는 사용자의 계좌 내에 사용자가 요청한 금액을 출금할 수 있는 충분한 액수의 금액이 존재하는지 확인을 해야 한다. 

만약, 충분한 액수가 존재하지 않는 경우, 특정 값을 리턴해 주어 이를 확인할 수 있다. 예를 들어, 잔고가 부족한 경우라면 `-1` `0` 등의 값을 리턴해 주는 것이다. 
그러나, 이런 식으로 리턴 값으로 결과를 확인해야 한다면, 우리의 비즈니스 코드는  `if` 문으로 매번 결과를 확인해야 하기에 지저분해 질 것이며, 흐름을 파악하기 힘들거나, 리턴 값에 대한 혼동이 일어날 수도 있다. 

그래서, 이런 예외 상황에서 비즈니스적 의미를 띈, `InsufficientBalanceException` 과 같은 예외를 발생시켜 던질 수 있다. 이렇게 할 경우, 예외 처리에 대한 부분들은 모두 한 곳에  `catch`문을 모아 둘 수 있기 때문에 코드가 깔끔해 진다. 

이렇게 사용하게 될 어플리케이션 예외는 체크 에외로 만들어 주어 개발자가 잊지 않고, 예외 상황에 대한 처리를 진행할 수 있도록 해 주어야 한다. 

### 4.1.5 SQLException은 어떻게 됐나?

스프링의 JdbcTemplate는 런타임 예외 중심의 예외 전략을 사용한다. 즉, 템플릿과 콜백 내에서 발생하는 모든 `SQLException`을 런타임 예외인 `DataAccessException`으로 포장해서 던져준다. 그래서 JdbcTemplate를 사용하는 메서드들에서는 꼭 필요한 상황에서만 `DataAccessException`을 처리해 주며, 그 이외의 상황에서는 예외를 무시할 수 있게 된다. 
