## 2.4 스프링 테스트 적용

아직 아쉬운 점이 존재하는데, 바로 어플리케이션 콘텍스트 생성 방식이다. 
우리가 작성한 테스트 코드가 가지고 있는  `@Before` 메서드는 매 테스트 마다 새로 만들어진다. 즉, 해당 메서드에서 생성하는 어플리케이션 콘텍스트는 해당 테스트 클래스가 가지고 있는 테스트 메서드의 개수만큼 새로 생성된다. 

문제는, 빈이 많아지고 복잡해 질 수록, 어플리케이션 컨텍스트 생성에 더 많은 시간이 소요된다는 것이다. 
어플리케이션 컨텍스트는 만들어 질 때, 모든 싱글톤 빈 오브젝트를 초기화 한다. 또, 어떤 빈은 독자적으로 많은 리소스를 할당하거나, 독립적인 스레드를 띄우기도 한다. 이런 경우에는 테스트를 마칠 때 마다 해당 빈에게 할당된 리소스를 정리하지 않으면 다음 어플리케이션 컨텍스트의 생성 때 문제가 생길 수 있다.

원칙적으론 모든 테스트가 독립적으로 새로운 오브젝트를 만들어 사용하는것이 원칙이나, 어플리케이션 컨텍스트와 같이 생성에 많은 시간과 자원이 소모되는 경우에는 테스트 전체가 공유하는 오브젝트를 만들기도 한다. 
이것이 가능한 이유는, 어플리케이션 컨텍스트는 초기화 되고 나면 내부의 상태가 바뀌는 일이 거의 없기 때문이다. 때문에, 어플리케이션 컨텍스트는 한번만 생성 후 여러 테스트가 공유하여 사용하는 것이 가능하다. 

`JUnit`이 테스트 클래스의 오브젝트를 항상 새로 생성하기 때문에, 오브젝트 레벨에 어플리케이션 컨텍스트를 저장하는 것은 의미가 없다. 이를 해결하기 위해, `JUnit`은 전체 클래스에서 딱 한번만 실행되는 `@BeforeClass` `static` 메서드를 지원한다. 
이를 사용해 어플리케이션 컨텍스트를 스태틱 변수에 저장하는 방법으로도 문제를 해결할 수 있으나, 이보다는 스프링이 직접 제공하는 어플리케이션 컨텍스트 테스트 지원 기능을 사용하는 것이 더 편리하다.

### 2.4.1 테스트를 위한 어플리케이션 컨텍스트 관리

스프링은 `JUnit`을 이용한 테스트 컨텍스트 프레임워크를 제공한다. 이를 이용하면 간단한 어노테이션 설정만으로 테스트에서 필요로 하는 어플리케이션 컨텍스트를 만들어서 모든 테스트가 공유하게 할 수 있다. `UserDAOTest`에 이를 적용해 보자.

#### 스프링 테스트 컨텍스트 프레임워크 적용

먼저, `@Before` 메서드에서 어플리케이션 컨텍스트를 생성하는 코드를 제거한다. 이후, 테스트 클래스의 멤버 변수로 `ApplicationContext` 타입의 변수를 생성하고, `@Autowired` 어노테이션을 붙여준다. 마지막으로 클래스 레벨에 `@RunWith`와 `@ContextConfiguration` 어노테이션을 추가해 준다.
```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations="/applicationContext.xml")
public class UserDAOTest{
	@Autowired
	private ApplicationContext context;
	//...

	@Before
	public void setUp(){
		this.dao = this.context.getBean("userDAO", UserDAO.class);
	}
}
```

수정된 코드는 성공적으로 테스트를 통과할 것이다. 어떻게 간단한 어노테이션 만으로 `context` 변수가 초기화 된걸까?

`@RunWith` 어노테이션은 `JUnit` 프레임워크의 테스트 실행 방법을 확장하기 위해 사용한다. `SpringJUnit4ClassRunner`라는 `JUnit`용 테스트 컨텍스트 프레임워크 확장 클래스를 지정해 주면 `JUnit`이 테스트를 진행할 때 사용할 어플리케이션 컨텍스트를 만들고 관리해준다.
`@ContextConfiguration`은 자동으로 만들어 줄 어플리케이션 컨텍스트 설정파일의 위치를 지정한 것이다.

#### 테스트 메서드의 컨텍스트 공유

위의 과정을 조금 더 확인해 보자. 
`@Before` 클래스를 다음과 같이 수정한다.
```java
@Before
public void setUp(){
	System.out.println(this.context);
	System.out.println(this);
}
```

이후 테스트 메서드를 실행해 테스트 메서드의 `context` 변수와 테스트 클래스의 인스턴스 정보를 확인할 수 있다.
그 결과, 서로 다른 테스트 클래스 인스턴스에서 모두 같은 `context`가 사용되었음을 알 수 있다.

스프링의 `JUnit` 확장 기능이 테스트가 실행되기 전 딱 한번만 어플리케이션 컨텍스트를 만들어두고, 테스트 오브젝트가 만들어 질 때 마다 특별한 방법을 이용해 어플리케이션 컨텍스트를 주입해 주는 것이다. 일종의 DI에 해당되나, 어플리케이션 오브젝트 사이의 관계를 관리하기 위한 DI와는 성격이 조금 다르다.

아무튼, 이를 이용해 어플리케이션 컨텍스트를 공유하여 오버헤드를 효과적으로 줄일 수 있다. 

#### 테스트 클래스의 컨텍스트 공유

스프링 테스트 컨텍스트 프레임워크는 하나의 테스트 클래스에서만 어플리케이션 컨텍스트를 공유해 주는 것이 아니라, 같은 설정파일에 해당하는 모든 테스트 클래스에 대해서 어플리케이션 컨텍스트를 공유해 준다.

#### @Autowired

`@Autowired`는 스프링의 DI에서 사용되는 특별한 어노테이션이다. 이를 이용한 DI 방법은 VOL.2에서 설명할 것이기에 지금은 간단하게 다음과 같이 기억해 두자.

`@Autowired`가 붙은 인스턴스 변수가 있으면, 테스트 컨텍스트 프레임워크는 변수 타입과 일치하는 컨텍스트 내의 빈을 찾는다. 타입이 일치하는 빈이 있다면, 해당 빈을 주입해 준다. 일반적으로는 의존관계 주입을 위해 생성자나 수정자 메서드가 필요하지만, 이 경우에는 메서드 없이도 주입이 가능하다. 또, 별도의 DI 설정 없이도 필드의 타입 정보를 이용해 빈을 자동으로 가져올 수 있는데, 이를 타입에 의한 자동 와이어링 이라고 한다. 

스프링 어플리케이션 컨텍스트는 초기화를 할 때, 자기 자신도 빈으로 등록한다. 즉, `ApplicationContext` 타입의 빈이 존재하는 셈이고, 덕분에 DI 역시 가능해 진다. 

이렇게 빈을 자동으로 주입받을 수 있다면, 이제 `UserDAO` 빈 역시 컨텍스트를 통해 가져오는 것이 아니라 `@Autowired`를 이용해 주입받을 수 있을것이다. 그렇다면 어플리케이션 컨텍스트는 더이상 필요하지 않게 된다.
```java
//...
public class UserDAOTest{
	@Autowired
	UserDAO dao;
}
```

`@Autowired`는 변수에 할당 가능한 타입을 가진 빈을 자동으로 찾는다. 때문에 특정 구현 클래스 타입은 물론, 인터페이스의 타입을 벼수로 선언해도 된다. 
단, `@Autowired`는 같은 타입의 빈이 두 개 이상 있는 경우에는 타입만으로 주입할 빈을 결정할 수 없다. 이 때는 변수의 이름과 같은 빈이 있는지 확인한다. 그리고, 변수 이름으로도 빈을 찾을 수 없는 경우에는 예외가 발생한다.

그렇다면, `DataSource` 인터페이스를 구현한 `SimpleDriverDataSource` 타입을 사용하기 위해선 어떤 타입으로 변수를 선언하는 것이 좋을까?
이는 용도에 따라 달라진다. 

단순히 `DataSource` 인터페이스에 정의된 메서드를 테스트에서 사용하기 위해선 `DataSource` 타입으로 주입받는 것이 좋다. 이 경우, 구현 클래스의 변경에서도 코드의 수정이 일어나지 않기 때문이다.
반면, 테스트에서 특정 구현 클래스 타입의 오브젝트 자체에 관심이 있을 수 있다. 이 경우 구현 클래스 `SimpleDriverDataSource` 타입의 변수를 사용하는 것 역시 가능하다. 
테스트는 필요하다면 얼마든지 어플리케이션 클래스와 밀접한 관계를 맺고 있어도 괜찮다. 일부 테스트는 코드의 내부 구조 및 설정등을 알고, 의도적으로 그 내용을 검증해야 할 때가 있기 때문이다. 하지만, 꼭 필요한 경우가 아니라면 가능하면 인터페이스를 사용해 어플리케이션 코드와 느슨하게 연결을 해 두자.

### 2.4.2 DI와 테스트

만약, 특정 구현 클래스만 사용할 것으로 예상되는 환경이라면, 인터페이스를 사용하고, DI를 통해 의존관계를 주입 받는 것이 이점을 가질 수 있을까?
인터페이스를 사용해 DI를 적용해야 하는 이유를 생각해 보자.

1. 소프트웨어 개발에서 절대로 바뀌지 않는 것은 없다.
클래스 대신 인터페이스를 사용하고, DI를 통해 주입받는 것은 아주 간단하고 쉬운 작업이다. 이를 사용한다면, 언젠가 변경이 필요한 상황이 닥쳤을 때 수정에 들어가는 시간과 비용이 훨씬 절감된다. 

2. DI를 적용하면 다른 차원의 서비스 기능을 도입할 수 있다.
이전에 만들어봤던, DB 커넥션 개수를 카운팅 하는 예제처럼 DI를 적용한다면 기존 코드의 수정 없이도 간단하게 부가 기능을 추가할 수 있다._(실제 사용하는 구현 클래스와 코드 사이에 같은 타입의 부가기능을 위한 클래스를 하나 더 추가하는 방식이다.)_ 설정 파일을 수정하는 것 만으로 부가기능을 손쉽게 추가/제거 할 수 있는 것 역시 인터페이스를 이용한 DI의 장점이다.
스프링은 이런 기법을 일반화 하여 AOP라는 기술을 만들었으며, 이는 6장에서 설명한다.

3. 효율적인 테스트를 만들기 위해서 역시 DI 적용이 필요하다.
테스트를 잘 활용하기 위해선 자동으로 실행 가능하고, 빠르게 동작하도록 테스트 코드를 작성해야 한다. DI는 테스트가 작은 단위 대상에 대해 독립적으로 만들어 지고 실행되게 하는 데 중요한 역할을 한다.

테스트에 DI를 이용하는 방법들을 살펴보자.

#### 테스트 코드에 의한 DI

우리는 이미 DI가 어플리케이션 컨텍스트와 같은 스프링 컨테이너에서만 가능한 작업이 아님을 알고 있다. 수정자 메서드를 이용한 의존관계 주입은 얼마든지 테스트 코드에서도 사용할 수 있다. 예를 들어, `UserDAO`가 사용할 `DataSource` 오브젝트를 테스트 코드에서 변경할 수 있다.

만약, `applicationContext.xml`에 정의된 `DataSource` 빈이 운영용 DB 서버에 연결되어 있다고 가정해 보자. 이 `DataSource`를 테스트에 사용하는 것은 매우 좋지 않다. 하지만, `applicationContext.xml` 의 내용을 운영/테스트 마다 계속 수정하는 것 역시 비효율적이다. 이 경우, 테스트 코드에서 DI를 통해 테스트에서 `UserDAO`가 사용할 `DataSource` 빈을 교체해 줄 수 있다.

테스트용 DB에 연결해 주는 `DataSource`는 테스트에서 직접 만들어서 사용하자. 구현 클래스는 스프링에서 제공하는 `SingleConnectionDataSource`를 사용한다. 
`@Before` 메서드에서 테스트용 `DataSource`를 생성하고, `dao` 오브젝트의 `setDateSource()` 메서드로 의존관계를 주입해 주자.
```java
@DirtiesContext
public class UserDAOTest{
	@Autowired
	UserDAO dao;

	@Before
	public void setUp(){
		//...
		DataSource dataSource = new SingleConnectionDataSource(
		"jdbc:mysql://localhost/testdb", "spring", "book", true);
		dao.setDataSource(dataSource);
	}
}
```

위 방법으로 XML을 수정하지 않고도 오브젝트 관계를 재구성 할 수 있다. 즉, 예외상황을 발생시키기 위해 이상한 오브젝트를 주입하거나, 테스트용으로 준비된 오브젝트를 사용할 수 있다. 

하지만, 이미 설정 정보를 따라 어플리케이션 컨텍스트가 구성한 오브젝트를 가져와 의존 관계를 강제로 변경했기 떄문에, 주의해야 한다. 스프링 테스트 컨텍스트 프레임워크를 적용했다면, 어플리케이션 컨텍스트는 테스트 도중 딱 한번만 만들어지며, 같은 컨텍스트를 공유한다. 때문에, 위 코드에서는 나머지 모든 테스트를 수행할 때 역시 변경된 어플리케이션 컨텍스트를 사용하게 되며, 이는 바람직하지 못하다.
어플리케이션 컨텍스트의 구성이나 상태는 테스트 내에서 변경하지 않는 것이 바람직하다.

그래서 `UserDAOTest`에는 `@DirtyContext`라는 어노테이션이 추가되었다. 이 어노테이션은 스프링의 테스트 컨텍스트 프레임워크에게 해당 클래스의 테스트에서 어플리케이션 컨텍스트의 상태가 변경되었음을 알려준다. 테스트 컨텍스트는 해당 어노테이션이 붙은 테스트 클래스에게는 어플리케이션 컨텍스트의 공유를 허용하지 않는다. 
즉, 매번 새로운 어플리케이션 컨텍스트를 만들어 다음 테스트가 사용하도록 해준다.

>**메서드 레벨의 `@DirtyContext` 사용하기**
>
>해당 어노테이션은 개별적인 메서드에도 적용이 가능하다. 이 경우, 해당 어노테이션을 사용한 메서드의 실행이 끝나고 나면, 이후 진행되는 테스트를 위해 변경된 어플리케이션 컨텍스트가 폐기되고, 새로운 어플리케이션 컨텍스트가 생성된다.

하지만, 어플리케이션 컨텍스트를 매번 만들게 하는 것은 좋은 접근이 아니다.

#### 테스트를 위한 별도의 DI 설정

테스트 코드에서 빈 오브젝트에 수동으로 의존관계를 주입하는 것은 단점이 많다. 때문에, 이번에는 테스트에서 사용할 테스트 전용 설정파일을 따로 만드는 방법을 사용해 본다. 이제, 우리는 두 가지 종류의 설정파일을 만들고, 하나에는 서버에서 운영용으로 사용할 `DataSource`를, 다른 하나에선 테스트에 적합하게 준비된 DB를 사용하는 `DataSource`를 빈으로 등록한다.
그리고, 테스트에서는 항상 테스트 전용 설정파일을 사용하도록 해 준다.

우선, 기존의 `applicationContext.xml`을 복사해 `test-applicationContext.xml`을 만들자. 그리고, `dataSource` 빈의 설정을 테스트용으로 수정한다.
```xml
<bean id="dataSource" class = "...SimpleDriverDataSource" >
	<property name="driverClass" value="...Driver" />
	<property name="url" value=".../localhost/testdb" />
	<property name="username" value="spring" />
	<property name="password" value="book" />
</bean>	  
```

다음으로, `UserDAOTest`의 `ContextConfiguration` 어노테이션에 있는 `location`의 값을 새로 만든 테스트용 설정 파일로 변경해 주면, 해당 테스트 클래스는 새로 만든 설정 파일을 이용해 의존관계를 설정하게 된다.
```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations="/test-applicationContext.xml")
public class UserDAOTest{ 
//...
}
```

#### 컨테이너 없는 DI 테스트 

마지막으로, 스프링 컨테이너를 사용하지 않고 테스트를 만드는 방법을 알아보자.

`UserDAO`나 `DataSource`의 구현 클래스 어디에도 스프링 API를 사용하거나, 어플리케이션 컨텍스트를 이용하는 등 스프링 DI 컨테이너에 의존하지 않는다. 때문에, 스프링 DI 컨테이너를 이용해 오브젝트를 생성하는 대신, 직접 오브젝트를 생성하고 의존관계를 설정해도 된다.

이번에는 스프링 컨테이너를 사용하지 않기 때문에 `@RunWith`, ,`@Autowired`를 사용할 필요가 없다. 대신, `@Before` 메서드에서 직접 `UserDAO` 오브젝트를 생성하고, 테스트용 `DataSource` 오브젝트를 주입해 주면 된다.
```java
public class UserDAOTest{
	UserDAO dao;

	@Before
	public void setUp(){
		dao = new UserDAO();
		DataSource dataSource = new SingleConnectionDataSource(
		"jdbc:mysql://localhost/testdb", "spring", "book", true);
		dao.setDataSource(dataSource);
	}
}
```

직접 오브젝트를 생성하는 것은 번거로움이 있지만, 어플리케이션 컨텍스트를 사용하지 않기 때문에 코드가 더 단순해지고, 이해하기 편해졌다. 또, 어플리케이션 컨텍스트를 생성하지 않기 때문에 테스트 시간도 절약할 수 있다. 

물론, `JUnit`은 매번 새로운 테스트 클래스 오브젝트를 생성하고, 이에 따라 매번 새로운 `UserDAO` 오브젝트가 만들어 진다는 단점이 존재하기는 한다. 하지만, `UserDAO` 오브젝트는 가벼운 오브젝트이며, 큰 부담은 없다.

위에서 본 것 처럼 DI를 위해 컨테이너가 반드시 필요한 것은 아니다. DI는 단지 객체지향 프로그래밍의 스타일이며, DI 컨테이너나 프레임워크는 DI를 편하게 적용하도록 도움을 줄 뿐, 컨테이너가 DI를 가능케 하는 것은 아니다.

>**침투적 기술과 비침투적 기술**
>
>침투적 기술이란, 기술을 적용했을 때 어플리케이션 코드에 기술 관련 API가 등작하거나, 특정 인터페이스/클래스의 사용을 강제하는 기술을 말한다. 침투적 기술을 사용하면 어플리케이션 코드가 해당 기술에 종속되는 결과를 가져온다. 
>반면, 비침투적 기술은 어플리케이션 로직을 담은 코드에 아무런 영향을 주지 않은 채 적용이 가능하다. 때문에 기술에 종속적이지 않은 순수한 코드를 유지할 수 있돌고 해준다. 
>스프링 역시 비침투적 기술의 대표적인 예이며, 때문에 스프링 컨테이너를 사용하지 않는 DI 역시 가능한 것이다.

#### DI를 이용한 테스트 방법 선택

위에서 살펴본 세 가지 방법은 모두 장단점이 있으며, 상황에 따라 적절하게 선택 가능하다. 

스프링 컨테이너 없이 테스트가 가능하다면, 해당 방법을 최우선으로 고려하는 것이 좋다. 이 방법이 테스트 수행 속도가 가장 빠르며, 테스트 역시 간결하기 때문이다. 테스트를 위해 필요한 오브젝트 생성과 초기화가 단순하다면, 이 방법이 최선이다.
반면, 여러 오브젝트와 복잡한 의존관계를 갖고 있는 오브젝트의 경우 스프링의 설정을 이용해 DI를 진행하는 것이 편리하다. 이 때는 테스트 환경과 개발환경의 설정을 따로 분리하는 것이 좋다.
때로는 예외적인 의존관계를 강제로 구성해야 하는 경우가 존재하는데, 이 때 수동으로 DI를 하는 방법을 사용하면 된다. 이 때는 꼭 `@DirtiesContext` 어노테이션을 붙여야 함을 잊지 말자.
