## 2.2 UserDAOTest 개선

이번 섹션에서는 이전 섹션에서의 두가지 문제점을 개선해 본다.

### 2.2.1 테스트 검증의 자동화

이전 섹션에서 알아봤던 테스트 결과의 검정부분 문제를 코드로 만들어 보자.
코드로 만든 테스트에서 확인하고 싶은 사항은 `add()`를 통해 저장된 `User` 오브젝트의 사용자 정보와 `get()`을 통해 조회한 `User` 오브젝트의 정보가 서로 정확하게 일치하는가 이다. 모든 정보가 일치한다면, 모든 정보가 DB에 잘 저장되고, DB에서 잘 조회되었음을 알 수 있다.

먼저 테스트의 결과를 생각해 보자.
모든 테스트는 성공과 실패, 두 가지 결과를 가질 수 있다. 또, 테스트의 실패는 테스트 진행 도중 에러가 발생하는 경우와, 에러가 발생하지 않았지만 기댓값과 다른 결과가 나오는 경우로 구분할 수 있다. 이 책에서는 전자를 테스트 에러, 후자를 테스트 실패로 구분하여 부른다.

테스트 중 에러가 발생할 경우, 콘솔에 에러 메시지와 호출 스택 정보가 출력되기에 확인하기 쉽다. 하지만, 테스트 실패의 경우, 확인 작업으 진행되어야 한다. 확인 작업 간편화를 위해, 테스트가 성공한 경우 `테스트 성공`, 테스트가 실패한 경우 `테스트 실패` 라고 출력하자. 수정 이후의 테스트 코드는 다음과 같다.
```java
if(!user.getName().equals(user2.getName()))
	System.out.println("테스트 실패 (name)");
else if(!user.getPassword().equals(user2.getPassword()))
	System.out.println("테스트 실패 (password)");
else
	System.out.println("조회 테스트 성공");
```

이제 `main()` 메서드를 실행하는 것 만으로 간단하게 성공 메시지를 확인할 수 있다.

자동화된 테스트를 위해 `xUnit` 프레임워크를 만든 켄트 백은 _'테스트란 개발자가 마음 편하게 잠자리에 들 수 있게 해주는 것'_ 이라고 했다. 이렇게 테스트 코드를 작성해 두면, 코드의 수정 이후에도 편하게 코드의 정상적인 동작을 검증할 수 있다. 

### 2.2.2 테스트의 효율적인 수행과 결과 관리

이제 테스트 코드는 테스트로서 필요한 기능을 모두 갖추었다. 하지만, `main()` 메서드로 테스트 코드를 구성하는 것은 편리하게 테스트를 수행하는 데 있어 한계가 있다. 

자바에는 실용적인 테스트를 위한 다양한 프레임워크가 있고, 책에서는 그 중에서도 `JUnit` 이라는 테스트 지원 도구를 설명한다.

#### JUnit 테스트로 전환

이제 `main()` 메서드로 작성된 테스트 코드를 `JUnit`으로 전환한다. `JUnit`은 **프레임워크**이기에 개발자가 만든 클래스에 대한 제어권한을 넘겨받아 주도적으로 어플리케이션 흐름을 제어한다. (**IoC**) 때문에 클래스의 동작 실행을 위한 `main()` 메서드를 만들거나 실행시킬 필요가 없다.

#### 테스트 메서드 전환

우리가 가장 먼저 할 일은 `main()` 메서드에 존재하던 코드를 일반 메서드로 옮기는 것이다. `main()` 메서드로 구성된 코드는 직접 제어권을 갖는 것을 의미하며, 이는 프레임워크에 적용하기에 적합하지 않기 때문이다.

새로 만들 테스트 메서드는 `JUnit` 프레임워크가 요구하는 두 가지 조건을 만족해야 한다.
1. 메서드는 `public`으로 선언 되어야 한다.
2. 메서드에는 `@Test` 어노테이션을 붙여야 한다.

아래는 새로 생성한 테스트 메서드이다.
```java
public class UserDAOTest{
	@Test
	public void addAndGet() ...{
		ApplicationContext c = new 
		ClassPathXmlApplicationContext("applicationContext");

		UserDAO dao = context.getBean("userDAO", UserDAO.class);
		//...
	}
}
```

이제 테스트 메서드는 `main()` 대신 테스트의 의도를 알 수 있는 적절한 이름을 사용한다. 

#### 검증 코드 전환

위에서 작성했던 검증을 위한 조건 분기(`if-else`)를 `JUnit`에 맞게 전환해 보자. 이 때 우리는 `JUnit`이 제공하는 `assertThat()` 메서드를 이용할 수 있다.

`assertThat()` 메서드는 첫 번째 파라미터의 값을 뒤에 나오는 `matcher` 조건으로 비교한다. 결과가 일치한다면 넘어가고, 그렇지 않다면 테스트가 실패하도록 만들어 준다. `is()` 역시 `matcher`의 일종으로, `equals()`로 비교해 주는 기능을 가졌다.
```java
assertThat(user2.getName(), is(user.getName()));
assertThat(user2.getPassword(), is(user.getPassword()));
```

`JUnit`은 예외가 발생하거나, `assertThat()`에서 실패하지 않은 경우 테스트가 성공했다고 인식한다. `JUnit`은 테스트 결과를 다양한 방법으로 알려주기 때문에 `'테스트 성공'` 이라는 메시지를 출력할 필요는 없다.

#### JUnit 테스트 실행

`JUnit` 프레임워크 역시 자바 코드로 만들어진 프로그램이기에 어디선가 `JUnit` 프로그램을 시작해 주어야 한다. 어딘가에 `main()` 메서드를 추가하고, `JUnitCore` 클래스의 `main()` 메서드를 호출해 주는 코드를 작성하면 된다. 메서드 파라미터에는 `@Test` 테스트 메서드를 가지고 있는 클래스의 이름을 넣어준다. 
```java
public static void main(){
	JUnitCore.main("springbook.user.dao.UserDAOTest");
}
```

실행 결과로는 테스트를 실행하는 데 걸린 시간과 테스트 결과, 실행된 테스트 메서드 개수 등을 알려준다.
만약 `assertThat()`에서 검증에 실패한 경우 `OK` 대신 `FAILURES!!` 메시지가 출력되며, 실패한 테스트의 개수를 보여준다. 더불어, 함께 출력된 호출 스택을 살펴보면 실패한 원인과 위치를 확인할 수 있다.
