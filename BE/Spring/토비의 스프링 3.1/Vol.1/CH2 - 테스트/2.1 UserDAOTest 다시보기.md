## 2.1 UserDAOTest 다시보기

1장에서, 우리는 직접 구현한 `UserDAO`의 동작을 확인하기 위해 테스트 코드를 만들었다. 이 때의 테스트 방법은 `main()` 메서드에서 `UserDAO`의 각 메서드를 호출하고, 결과를 화면에 출력하는 방식이었다.

이 덕분에 우리가 진행하는 리팩토링 동안, `UserDAO`가 변함 없이 잘 동작함을 확인할 수 있었다. 

이 처럼 테스트 코드는 우리가 구현한 코드가 정확하게 동작한다는 것을 확신할 수 있게 해주는 작업이다. 

### 2.1.2 UserDAOTest의 특징

우리가 이전에 작성했던 테스트 코드를 다시 살펴보자. 아래 코드는 원문의 테스트 코드를 일부 수정하여 간단하게 바꾼 것이다.

```java
public class UserDAOTest{
	public void main(){
		ApplicationContext c = new GenericXmlApplicationContext(
			"applicationContext.xml");
		UserDAO dao = c.getBean("userDAO", UserDAO.class)
	
		User user = new User("Id", "이름", "password");
		dao.add(user);
	
		System.out.println(user.getId() + "등록 성공");
	
		User user2 = dao.get(user.getId());
		System.out.println(user2.getName());
		System.out.println(user2.getId() + "조회 성공");
	}
}
```

위 테스트는 `main()` 메서드를 이용해 쉽게 테스트 수행을 가능하게 했으며, 테스트 대상인 `UserDAO`를 직접 호출하여 사용한다.

#### 웹을 통한 DAO 테스트 방법의 문제점

보통 웹 프로그램에서 사용할 DAO를 테스트 할 때는 해당 서비스의 MVC 계층들을 모두 구현한 후 웹 상에서 직접 특정 동작을 수행하며 테스트를 진행한다. 다만, 이 방법은 너무 많은 변수가 존재한다. 즉, 제대로 동작하지 않는 상황에서의 문제가 DAO의 문제라고 확신할 수 없다.

테스트하고 싶은 대상은 `UserDAO` 객체였지만, 다른 계층의 코드나 서버의 설정 상태까지도 테스트에 영향을 줄 수 있기에 오류 상황에서 정확하게 대응하기가 힘들어진다.

어떻게 하면 효율적으로 테스트를 활용할 수 있을까?

#### 작은 단위 테스트

테스트 하고자 하는 대상이 명확하다면, 그 대상에만 집중해서 테스트 하는 것이 바람직하다. 때문에 테스트는 가능하면 작은 단위로 쪼개서 집중할 수 있어야 한다. 이 처럼 작은 단위의 코드에 대해서 테스트를 수행한 것을 **단위 테스트**_(unit test)_ 라 한다. 이 때의 단위는 범위가 정해진 것이 아니며, 충분히 하나의 관심에 집중해서 효율적으로 테스트할 만한 범위의 단위라고 생각하자. 

일반적으로, 단위는 작을 수록 좋다. 단위를 넘어서는 다른 코드들과는 상관없이, 심지어는 참여하지 않고 테스트가 동작할 수 있으면 좋다. 

다만, 통제할 수 없는 외부의 리소스에 테스트코드가 의존적이라면, 해당 테스트는 단위 테스트로서의 가치가 없어진다. 즉, DB의 상태가 매번 달라지며 테스트의 동작이 DB의 상태에 영향을 받게 된다면, 좋지 않다.

때로는 웹 사용자의 인터페이스부터 DB까지의 전체 어플리케이션 계층을 사용하며, 모든 기능에 대해 테스트를 진행하게 될 때도 있다. 각 단위 기능들은 잘 동작해도, 하나의 과정으로 합쳐지면 오류가 발생하는 경우가 있기 때문이다. 

이런 전체 과정을 테스트 하는 경우에도, 이전에 단위 테스트가 진행되었다면 각 단위별로 충분한 검증이 이루어 졌기 때문에 디버깅과 트러블슈팅이 쉬워진다.

#### 자동수행 테스트코드

우리가 작성한 테스트코드는 각 작업들이 코드를 통해 자동으로 실행된다. 

반대의 경우를 생각해 본다면, 웹 화면에서 우리가 작성한 화면을 띄우고, 직접 각 데이터 값을 삽입하며, 스스로 버튼을 누르는 테스트 과정을 생각할 수 있다. 이와 비교해, `main()` 메서드를 실행하는 방법만으로 모든 테스트 과정이 진행되는 것은 훨씬 간편하다.

테스트 코드는 이렇게 자동으로 수행되도록 코드로 만들어 지는 것이 좋다. 이 경우 테스트를 자주 반복할 수 있게 되기에 각 기능의 수정 이후 부담 없이 올바른 동작을 검증할 수 있게 된다. 

추가적으로, 테스트 코드는 어플리케이션을 구성하는 클래스 내부에 포함시키는 것 보다는 별도의 테스트용 클래스를 만들어 작성하는 편이 낫다. 클래스를 분리하고, 유연한 설계 구조로 발전시키면서 테스트 코드의 위치가 애매해지기 때문이다.

#### 지속적인 개선과 점진적인 개발을 위한 테스트

우리는 이전의 리팩토링 과정에서 매번 `UserDAOTest` 클래스를 통해 테스트를 진행하고, `UserDAO`의 동작을 검증받아 왔다. 덕분에 우리의 각 리팩토링마다 `UserDAO`의 정상적인 동작을 확인할 수 있었다. 

### 2.1.3 UserDAOTest의 문제점

앞서 살펴본 것 처럼, `UserDAOTest`는 이미 그 자체로 나름의 장점을 가지고 있다. 하지만 아래의 단점들 또한 함께 가지고 있다.

#### 수동 확인 작업의 번거로움

`UserDAOTest`는 각 작업들이 모두 자동으로 진행된다. 하지만, 입력 값과 반환 값이 일치하는지 확인하는 등의 검증 작업은 여전히 우리가 직접 확인해야 한다. 때문에, 아직은 우리의 단위 테스트는 완전히 자동화 되어 있지 않다. 테스트코드가 많아짐에 따라, 사람이 직접 확인해야 하는 값 역시 많아질 것이며, 이 과정에서 충분히 실수가 생길 가능성이 존재한다. 

#### 실행 작업의 번거로움

우리의 테스트 코드들은 간단하게 실행 가능한 `main()` 메서드를 사용한다. 하지만, 테스트를 해야 하는 객체가 많아지고, 이에 따라 테스트 코드 역시 많아진다면 테스트코드의 실행을 위해 `main()` 함수를 실행하는 것 역시 번거로워 질 것이다.
