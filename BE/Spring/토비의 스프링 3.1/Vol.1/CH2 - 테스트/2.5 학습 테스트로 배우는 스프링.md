## 2.5 학습 테스트로 배우는 스프링

**학습 테스트**라는 것은 자신이 만들지 않은 프레임워크나 다른 개발팀에서 만들어 제공한 라이브러리에 대해서 테스트를 작성하는 것이다. 이 목적은 라이브러리의 검증이 아닌, 자신이 사용할 API 기능을 테스트 해 보면서 사용 방법을 익히는 것이다.

### 2.5.1 학습 테스트의 장점

#### 다양한 조건에 따른 기능을 손쉽게 확인해 볼 수 있다.

이는 자동화된 테스트의 장점이 적용된 것이다. 다양한 조건에서 기능이 어떻게 다르게 동작하는지를 확인해 보기 위해 수동으로 값을 입력하거나, 코드를 수정하는 대신, 자동화된 테스트 코드를 사용하는 것이다. 

#### 학습 테스트 코드를 개발 중에 참고할 수 있다.

수동으로 예제를 만드는 방법은, 코드를 수정하면서 기능을 확인해 보기 때문에 최중 수정한 예제 코드만 남는다. 반면, 학습 테스트는 다양한 기능과 조건에 대한 테스트 코드를 개별적으로 만들고, 남겨둘 수 있다. 그리고, 이렇게 남은 코드들은 실제 개발의 샘플 코드로 사용할 수 있다. 

#### 프레임워크나 제품을 업그레이드 할 때 호환성 검증을 도와준다.

우리가 사용할 제품이 새로운 버전으로 업데이트 되고 나면 API 사용법에 미묘한 변화가 생기거나, 기존의 정상 동작 기능에 문제가 생길 수 있다. 
그러나, 이 경우 어플리케이션에서 자주 사용하는 기능들에 대해 테스트를 만들어 놓았다면, 새로운 버전의 프레임워크나 제품에 대한 변화를 미리 확인할 수 있다.

#### 테스트 작성에 좋은 훈련이 된다. 

당연히, 학습 테스트 또한 테스트 코드이기에 우리가 앞으로 작성될 테스트 코드와 비슷하게 작성된다. 또, 학습 테스트는 대부분 한,두가지 기능에만 초점을 맞추면 되기에 단순하게 작성할 수 있다.
즉, 학습 테스트 작성 또한 테스트 코드 작성에 대한 연습이 될 수 있다.

#### 새로운 기술을 공부하는 과정이 즐거워진다.

당연히, 책이나 레퍼런스 문서를 그저 읽는 지루한 공부보다, 테스트 코드를 주도적으로 작성하는 학습이 훨씬 즐겁지 않겠는가?

스프링 학습 테스트를 작성할 떄 참고할 수 있는 가장 좋은 소스 코드는 바로 스프링 자신에 대한 테스트 코드이다. 이는 스프링 배포판의 압축 내부에 존재하며, 이를 확인해 보는 것은 스프링 사용에 큰 도움이 될 것이다.

### 2.5.2 학습 테스트 예제

#### JUnit 테스트 오브젝트 테스트

우리는 `JUnit` 테스트 메서드를 수행할 때 마다 새로운 오브젝트가 생성됨을 알고있다. 이를 확인하기 위해 직접 테스트 코드를 작성해 보자.

테스트 시나리오는 다음과 같다.
1. 새로운 테스트 클래스를 만들고, 적당한 이름의 세 개의 테스트 메서드를 추가한다.
2. 테스트 클래스 자신의 타입으로 스태틱 변수를 선언한다.
3. 매 테스트 메서드에서 스태틱 변수에 담긴 오브젝트와 자신을 비교한다.
4. 오브젝트와 자신이 다름을 확인 후, 변수에 자신을 저장한다.

```java
public class JUnitTest{
	static JUnitTest testObj;

	@Test
	public void test(){
		assertThat(this, is(not(sameInstance(testObj))));
		testObj = this;
	}

	@Test
	public void test2(){
		assertThat(this, is(not(sameInstance(testObj))));
		testObj = this;
	}
	
	@Test
	public void test3(){
		assertThat(this, is(not(sameInstance(testObj))));
		testObj = this;
	}
}
```

테스트 코드에서 사용하는 매처가 추가되었다. `not`은 뒤에 나오는 결과를 부정해 주며, `sameInstance()`는 객체의 동일성비교를 위해 사용된다. 
물론, `equals()` 메서드를 오버라이드 하지 않았기 때문에 `equals()` 로도 동일성 비교를 진행할 수 있지만, 테스트의 의도를 명확하게 드러내기 위해 동일성 비교 매처를 명시적으로 사용한다.

하지만, 이 방법은 **바로 이전에 실행된 테스트**와만 비교가 진행된다.
이 점을 다음와 같이 개선할 수 있다.
```java
public class JUnitTest{
	static Set<JUnitTest> testObjs = new HashSet<>();

	@Test
	public void test1(){
		assertThat(testObjs, not(hasItem(this)));
		testObjs.add(this);
	}

	//동일하게 구현	
}
```

이 처럼 여러가지 매처를 사용해 적절하게 테스트를 작성해 볼 수 있다.

#### 스프링 테스트 컨텍스트 테스트

스프링 테스트용 어플리케이션 컨텍스트는 테스트 개수와 상관없이 한 개만 만들어 지고, 이는 공유된다. 이를 검증하는 코드를 작성해 보자.

우선, 테스트에 사용할 설정파일을 하나 작성하자. 학습 테스트는 가능하면 독립적으로 만드는 것이 좋으므로, 새로 설정파일을 생성한다. 이번 테스트는 DI기능을 활용하지 않기에 아무런 빈을 등록하지 않아도 된다. 해당 파일은 `JUnitTest`와 같은 패키지에서 생성한다.
```XML
<?xml ...?>
<beans xmlns="...">
</beans>
```

이제, 아까 만들었던 `JUnitTest`에 `@RunWith`과 `@ContextConfiguration`을 추가하자.
```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration
public class JUnitTest{
	@AutoWired
	ApplicationCOntext context;
	
	static Set<JUnitTest> testObjs = new HashSet<>();
	static ApplicationContext contextObj = null;

	@Test
	public void test1(){
		assertThat(testObjs, not(hasItem(this)));
		testObjs.add(this);
		assertThat(contextObj == null || contextObj == 
			this.context, is(true));
		contextObj = this.context;
	}

	//동일하게 구현
}
```

위 코드는 이제 한번이라도, `context` 변수에 다른 컨텍스트가 사용되면 실패한다.

위 방법에서 컨텍스트의 공유를 검증하는 부분은 여러 방법으로 작성될 수 있다.
먼저, 우리가 사용한 방법은 `assertThat()` 메서드의 첫번째 파라미터로 조건문을 사용하고, 이후 결과를 `is()` 매처로 비교하는 것이다.

두번째 방법으론 조건문의 결과를 확인하기 위해 `assertThat()` 메서드 대신 `assertTrue()` 메서드를 사용하는 방법으로 다음과 같다.
`assertTrue(contextObj == null || contextObj == this.context);`

마지막으로 조건문 대신 매처의 조합을 이용할 수 있다.
```java
assertThat(contextObj, 
	  either(is(nullValue())).or(is(this.context))
	  );
```

위의 매처 조합 역시 조건문과 같은 것을 확인해 준다.

이 처럼 다양한 방법 중 편하다고 생각하는 방법을 선택해 사용하면 된다. 

### 2.5.3 버그테스트

**버그 테스트**는 서비스의 코드에서 오류가 발생할 때, 해당 오류를 가장 잘 나타낼 수 있는 테스트를 말한다. 만약 우리가 작성한 코드에서 버그가 발생했다고 가정하자. 이 때, 무작정 코드를 뒤져가면서 수정하는 것 보다는, 버그 테스트를 먼저 작성하는 것이 좋다. 

버그 테스트는 우선 실패하도록 만들어야 한다. 우리가 발견한 버그가 원인이 되어 실패하는 코드를 만드는 것이다. 그러고 나서면, 우리의 목적은 어플리케이션 코드를 수정하여 버그 테스트를 성공시키는 것이다.

버그 테스트는 아래의 장점들을 가진다.

#### 테스트의 완성도를 높여준다.

기존 테스트에서 미처 검증하지 못한 부분이 있었기 때문에 오류가 발생했을 것이다. 우리는 버그 테스트를 새로 만들면서 불충분했던 테스트를 보완할 수 있으며, 앞으로의 문제 상황에서도 오류를 더욱 쉽게 추적할 수 있게 된다.

#### 버그의 내용을 명확하게 분석하게 해준다.

실패하는 버그 테스트를 작성하기 위해서는 문제의 원인을 명확하게 파악해야 한다. 또한, 해당 버그로 인해 발생할 수 있는 다른 버그를 발견할 수도 있게 된다. 버그 테스트를 작성하는 과정에서 이전에 분석해 보지 못했던 예외적인 상황을 조금 더 깊이 고민해 볼 수 있는 기회가 생기는 것이다.

#### 기술적인 문제를 해결하는 데 도움이 된다.

>**테스트 종류**
>- 동등 분할 (equivalence partitioning)
>같은 결과를 내는 값의 범위를 구분해 각 대표값으로 테스트를 하는 방법이다.<br>
>어떤 작업의 결과가 `true`, `false`, `Exception`의 세 가지 상황이라면, 각 결과를 내는 입력 값이나, 상황의 조합을 만들어 모든 경우에 대한 테스트를 하는 것이 좋다.
>
>- 경계값 분석 (boundary value analysis)
>에러는 동등분할 범위의 경계에서 주로 많이 발생한다는 특징을 이용해, 경계의 근처에 있는 값을 이용해 테스트하는 방법이다.<br>
>주로, 정수의 입력의 경우 0이나 그 주변 값, 정수의 최댓값, 최솟값 등으로 테스트를 해 보는 것이 도움이 된다.

