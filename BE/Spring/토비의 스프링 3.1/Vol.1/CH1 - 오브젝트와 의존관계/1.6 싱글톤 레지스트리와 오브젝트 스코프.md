## 1.6 싱글톤 레지스트리와 오브젝트 스코프

스프링 어플리케이션과 오브젝트 팩토리는 빈의 반환 과정에서 중요한 차이점이 있다.

`DAOFactory`를 이용해 얻는 오브젝트는 매번 다른 인스턴스를 반환한다.
반면에, 어플리케이션 컨텍스트는 여러번에 걸쳐 빈을 요청하더라도 동일한 오브젝트를 반환한다.

### 1.6.1 싱글톤 레지스트리로서의 애플리케이션 컨텍스트

어플리케이션 컨텍스트는 싱글톤을 저장하고 관리하는 싱글톤 레지스트리 이다.

#### 서버 어플리케이션과 싱글톤

스프링이 싱글톤으로 빈을 만드는 이유는, 스프링이 적용되는 대상이 자바 기술을 사용하는 서버 환경이기 때문이다.
만약, 매 클라이언트 요청마다 각 로직을 담당하는 오브젝트가 새로 만들어 진다면 오브젝트 생성에서 발생하는 오버헤드 때문에 서버에 부하가 심해진다. 때문에 대부분의 서블릿은 멀티스레드 환경에서 싱글톤으로 동작한다. 

#### 싱글톤 패턴의 한계

자바에서 싱글톤을 구현하는 방법은 보통 다음과 같다.

- 클래스 외부에서 오브젝트를 생성하지 못하도록 생성자를 `private`으로 만든다.
- 생성된 싱글톤 오브젝트를 저장할 수 있는 자신과 같은 타입의 `static`필드를 정의한다.
- `static` 팩토리 메서드인 `getInstance()`를 만들고, 최초 호출시 한번만 오브젝트가 만들어지게 한다. 생성된 오브젝트는 `static` 필드에 저장된다.
	- 또는, 초기값으로 미리 오브젝트를 만들어 둘 수도 있다.
	- `getInstance()` 메서드를 통해 이미 만들어져 있는 오브젝트를 넘겨준다.

일반적으로 싱글톤 패턴 구현방식은 다음의 문제가 있다.

##### `private` 생성자를 갖고 있기에 상속이 불가능하다.
객체지향의 장점인 상속과, 이를 이용한 다형성을 적용할 수 없다. 때문에 로직을 담고 있는 일반 로직의 경우 싱글톤으로 설계 되었다면 객체지향적인 설계의 장점을 적용하기 어렵다.
또한, `static`을 적용하는 필드, 메서드를 사용하는 것 또한 동일한 문제를 가진다.

##### 테스트하기 어렵다.
싱글톤은 만들어지는 방식이 제한적이기 때문에 Mock 오브젝트 등으로 대체ㅏ기 힘들다. 또, 초기화 과정에서 생성자 등을 통해 사용할 오브젝트를 동적으로 주입하기 어렵기 때문에 필요한 오브젝트는 직접 만들어 사용할 수 밖에 없다.

##### 서버 환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다.
서버에서 클래스 로더의 구성에 따라 싱글톤 클래스임에도 하나 이상의 오브젝트가 만들어 질 수 있다. 또, 여러개의 JVM에 분산되어 설치되는 경우 역시 독립적으로 오브젝트가 생기며 싱글톤으로서의 가치가 떨어진다.

##### 싱글톤 사용은 전역 상태를 만들 수 있다.
싱글톤은 사용하는 클라이언트가 정해져 있지 않기 때문에 어디서든 사용될 수 있다. 때문에 아무 객체나 자유롭게 접근 및 수정을 할 수 있는데, 이런 전역 상태는 객체지향 프로그래밍에서 권장되지 않는 프로그래밍 모델이다.

#### 싱글톤 레지스트리

스프링은 싱글톤이 만들어져 서비스 오브젝트 방식으로 사용되는 것을 지지한다. 하지만, 위와 같이 싱글톤 패턴 구현 방식은 단점이 존재하기에 스프링은 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공한다. 그것이 바로 **싱글톤 레지스트리** 이다. 

싱글톤 레지스트리는 `static` 메서드와 `private` 생성자를 사용하는 클래스가 아닌, 평범한 자바 클래스를 싱글톤으로 활용하게 해준다. 때문에 테스트 환경에서 자유롭게 오브젝트를 만들거나, Mock 객체로 대체하는 것 역시 가능하다. 
또, 생성자 파라미터를 이용해 사용할 오브젝트를 넣어줄 수 도 있다. 

가장 중요한 것은, 스프링이 지지하는 객체지향적인 설계방식과 원칙, 디자인패턴 등을 적용하는 데 아무런 제약이 없다는 점이다.

### 1.6.2 싱글톤과 오브젝트 상태

싱글톤은 멀티스레드 환경에서 여러 스레드가 동시에 접근해 사용할 수 있다. 때문에 상태 관리에 주의를 기울여야 한다. 기본적으로 싱글톤이 멀티스레드 환경에서 서비스 형태의 오브젝트로 사용되는 경우에는 상태 정보를 내부에 가지고 있지 않은 **stateless** 방식으로 만들어 져야 한다.

stateless 방식으로 클래스를 만드는 경우, 각 요청에 대한 정보나 DB, 서버의 리소스로부터 생성한 정보는 파라미터나 로컬 변수, 리턴 값 등을 이용하면 된다.
메서드 파라미터나 메서드 내부에서 생성되는 로컬 변수는 매번 새로운 값을 저장하기 위한 독립적인 공간이 만들어 지므로 여러 스레드가 변수의 값을 덮어쓸 일은 없다.

### 1.6.3 스프링 빈의 스코프

스프링이 관리하는 빈 오브젝트가 생성되고, 존재하고, 적용되는 범위를 빈의 스코프 라고 한다. 싱글톤 스코프는 컨테이너 내에 한 개의 오브젝트만 만들어 지며 강제로 제거되기 전까지는 스프링 컨테이너가 존재하는 동안 계속 유지된다. 
경우에 따라 싱글톤 이외의 스코프를 가지기도 하는데, 대표적으로는 프로토타입 스코프가 있다. 프로토타입은 컨테이너에 빈을 요청할 때 마다 새로운 오브젝트를 생성한다. 
이외에도 새로운 HTTP 요청마다 새로운 오브젝트가 생성되는 요청 스코프와, 웹의 세션과 스코프가 유사한 세션 스코프도 있다.
