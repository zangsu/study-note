## 1.2 DAO의 분리

### 1.2.1 관심사의 분리

사용자의 비즈니스 프로세스와 요구사항은 끊임없이 바뀐다. 애플리케이션의 기반 기술과 운영 환경 역시 변화한다. 때문에 개발자가 객체를 설계할 때 가장 염두에 두어야 하는 사항은 **미래의 변화를 대비하는 것** 이다. 변화를 대비하는 가장 좋은 대책은 **변화의 폭을 최소한으로 줄이는 것** 이다. 
변경이 일어날 때, 필요한 작업을 최소화 하고 변경이 다른 기능에 장애를 일으키지 않는 방법은 **분리와 확장**을 고려한 설계가 있었기 때문이다.

**분리**에 대해 먼저 생각해 보자. 대부분의 변경과 발전은 한번에 한가지 관심사항에 집중해서 일어난다. 즉, DB와 웹 프레임워크, 매출의 시스템과 데이터의 포멧이 한번에 바뀌지는 않는다. 
문제는, 변화는 대체로 집중된 한 가지 관심에 대해 일어나는 반면, 그에 따른 작업은 한 곳에 집중되지 않는 경우가 많다는 것이다. 
변화가 한 번에 한 가지 관심에 집중돼서 일어난다면, 우리가 준비해야 할 일은 **한 가지 관심이 한 군데에 집중되게 하는 것**이다. 즉, 관심이 같은 것 끼리는 모으고, 관심이 다른 것은 따로 떨어져 있게 하는 것이다. 

프로그래밍 기초 개념 중 **관심사의 분리**를 객체지향에 적용해 보면, 관심이 같은 것 끼리는 하나의 객체 안으로, 또는 연관성이 큰 객체로 모이게 하고 관심이 다른 것은 가능한 분리하여 서로 영향을 주지 않도록 하는 것이다. 

### 1.2.2 커넥션 만들기의 추출

기존의 `UserDAO`의 `add()` 메서드를 확인해 보면 다음의 세가지 관심사항을 발견할 수 있다.
1. DB 연결을 위한 커넥션을 가져온다.
	1. 어떤 DB, 어떤 드라이버를 사용할 것인지
	2. 어떤 로그인 정보를 쓰는 것일지
	3. ...
2. 사용자 등록을 위해 DB에 보낼 SQL 문장을 담을 `Statement`를 만들고, 실행시킨다.
	1. 파라미터로 넘어온 사용자 정보를 `Statement`에 바인딩 시킨다.
	2. `Statement`에 담긴 SQL을 DB를 통해 실행시킨다.
3. 사용한 리소스인 `Statement`와 `connection` 객체를 닫아 리소스를 반환한다.

가장 문제가 되는 것은 DB `connection` 객체를 가져오는 것이다. 이 코드는 `get()` 메서드에도 중복되어 있다. 이렇게 하나의 관심사가 여러 곳에 중복되고, 여기저기 흩어져 다른 관심과 섞여 있으면 리팩토링이 힘들어진다.

#### 중복 코드의 메서드 추출

위에서 설명한 DB 연결 코드를 `getConnection()` 메서드로 추출하여 독립적인 메서드로 만들어 준다. 이제 각 DAO 메서드에서는 분리한 `getConnection()` 메서드를 이용해 DB 커넥션을 가져올 수 있다. 앞으로는 DB 종류와 접속 방법이 바뀌어 드라이버 클래스와 URL이 바뀌는 등의 상황에서도 `getConnection()` 메서드의 코드만 수정하면 된다. 또, 다른 메소드에는 영향을 주지 않기에 수정도 간단해 졌다.

#### 변경 사항에 대한 검증 : 리펙토링과 테스트

메서드의 검증을 위해 `main()` 함수로 테스트를 진행할 수 있다. 하지만, `main()` 함수를 여러번 실행하면 테이블의 기본키인 `id` 값이 중복되면서 두번째부터 무조건 예외가 발생한다. 이제 `main()` 함수의 테스트 메서드 시작 전에 DB의 정보를 모두 삭제해 주자.

### 1.2.3 DB 커넥션 만들기의 독립

이제, 특정 DB에 의존적이지 않는 DAO를 설계해 보자.

#### 상속을 통한 확장

이제 우리는 `getConnection()` 이라는 추상 메서드를 사용하자. 이 메서드는 메서드의 구현 코드는 존재하지 않으며, 메서드 자체로만 존재한다. 따라서 `add()`, `get()` 메서드에서 여전히 `getConnetion()` 메서드를 호출할 수 있다.

추후 사용자들은 `UserDAO` 클래스를 상속한 그들만의 서브 클래스에 `getConnection()` 메서드를 원하는 방식으로 구현할 수 있다. 이를 통해 `UserDAO` 클래스의 수정 없이 상속한 서브클래스에서 `getConnection()` 메서드만 새로 구현하여 다양한 DB를 사용할 수 있게 된다. 

기존에는 **같은 클래스 안의 다른 메서드로 분리**되었던 DB 커넥션 연결이라는 관심을 아에 **상속을 통해 서브 클래스로 분리** 해버리는 것이다.

아래는 추상 메서드로 변경된 `getConnection()` 부분을 기술한다.
p.66


```java
public abstract class UserDAO{
	//...
	public abstract Connection getConnection() throws ...;
	//...
}

//상속 클래스
public class CustomUserDAO extends UserDAO{
	//...
	public Connection getConnection() throws ...{
		//== 추상 클래스의 구현부 ==//
	}
	//...
}
```

이제 DAO의 핵심 기능인 데이터의 등록과 조회 _(sql 작성, 파라미터 바인딩, 쿼리 실행, 검색 정보 전달)_ 의 관심을 담당하는 `UserDAO`와 DB 연결 방법을 결정짓는 `CustomDAO`가 클래스 레벨로 구분이 된다. 

이처럼, 슈퍼 클래스에 기본적인 로직의 흐름 _(커넥션 가져오기, SQL 생성, 실행, 반환)_ 을 만들고 그 기능의 일부를 추상 메서드나 오버라이딩이 가능한 `protected` 메서드 등으로 만든 뒤 서브클래스에서 이를 구현하는 방법을 **템플릿 메서드 패턴** 이라고 한다. 또는, 서브 클래스에서 구체적인 오브젝트 생성 방법을 결정짓게 하는 것을 **팩토리 메서드 패턴** 이라고 부르기도 한다.
- 즉, 각각의 구현 서브클래스에서 생성되는 특정 객체의 종류가 다르다면 팩토리 메서드 패턴으로 이해할 수 있다.

>**디자인 패턴**<br>
>디자인 패턴은 소프트웨어 설계 시 특정 상황에서 자주 만나는 문제를 해결하기 위해 사용할 수 있는 재사용 가능한 솔루션을 말한다. 
>디자인 패턴은 주로 객체지향 설계에 관한 것이고, 객체지향적 설계 원칙을 이용해 문제를 해결한다. 패턴 설계 구조를 보면 대부분 비슷한데, 이는 객체지향적인 설계로부터 문제를 해결하기 위해 적용할 수 있는 확장성 추구 방법이 대부분 두가지 구조로 정리되기 때문이다.
>- 클래스 상속
>- 오브젝트 합성
>
>패턴에서 가장 중요한 것은 각 패턴의 핵심이 담긴 목적, 또는 의도이다. 
>패턴을 적용할 상황, 해결해야 할 문제, 솔루션의 구조와 각 요소의 역할과 함께 **핵심 의도**가 무엇인지 기억해 두어야 한다.
>- 추천 도서
>	- [GoF의 디자인 패턴]
>	- [Head First Design Patterns]

>**템플릿** 메서드 패턴<br>
>상속을 통해 슈퍼클래스의 기능을 확장할 떄 사용하는 가장 대표적인 방법이다. 변하지 않는 기능은 슈퍼클래스에 만들어 두고, 자주 변경되어 확장할 기능은 서브 클래스에서 만들도록 한다.
>슈퍼 클래스에서는 미리 추상 메서드, 또는 오브라이드 가능한 메서드를 정의 해 두고 이를 활용해 코드의 기본 알고리즘을 담고 있는 템플릿 메서드를 만든다. 이처럼, 슈퍼클래스에서 디폴트 기능을 정의해 두거나, 비워두어 서브클래스에서 선택적으로 오버라이드 할 수 있도록 만들어 둔 메서드를 **훅(hook) 메서드** 라고 한다.

> **팩토리** 메서드 패턴<br>
>템플릿 메서드 패턴과 마찬가지로 상속을 통해 기능을 확장하는 패턴이다.
>슈퍼 클래스 코드에서는 서브클래스에서 구현할 메서드를 호출해서 필요한 타입의 오브젝트를 가져와 사용한다. 이 메서드는 주로 인터페이스 타입으로 오브젝트를 리턴하기 때문에 서브클래스에서 정확히 어떤 클래스의 오브젝트를 만들어 리턴할지는 슈퍼클래스에서 알지 못하며, 중요하지도 않다.
>서브 클래스는 다양한 방법으로 오브젝트를 생성하는 메서드를 재정의할 수 있다. 이렇게 서브클래스에서 오브젝트 생성 방법과 클래스를 결정할 수 있도록 미리 정의해둔 메서드를 팰토리 메서드라고 한다. 그리고, 이 방식으로 오브젝트 생성 방법을 나머지 로직과 독립시키는 방법을 팩터리 메서드 패턴이라고 한다.
>
>자바에서 종종 오브젝트를 생성하는 기능을 가진 메서드를 팩토리 메서드라고 부르기도 하나, 의미가 다르므로 혼동하지 말자.

이렇게 상속을 사용하면 단점이 있다. 만약 이미 `UserDAO`가 특정 기능을 위해 상속을 상속하고 있다면 다른 기능을 위해 상속을 사용할 수 없다. 즉, 자바에서는 다중 상속이 불가능하다.

또 다른 문제는, 상속을 통한 상하위 클래스의 관계는 생각보다 밀접하다는 점이다. 서브클래스는 슈퍼 클래스의 기능을 직접 사용할 수 있고, 슈퍼클래스 내부의 변경이 있을 때 서브클래스를 함께 수정해야 할 가능성이 있다.

확장된 기능인 DB 커넥션을 생성하는 코드를 다른 DAO 클래스에 적용할 수 없다는 것 역시 큰 단점이다. 여러 DAO 클래스가 만들어 질 때 마다 `getConnection()` 구현 코드가 중복되어 나타나게 될 것이다.
